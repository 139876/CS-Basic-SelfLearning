#数据结构 #算法 #C 

# [84] 插入排序
## 1. 算法思想
每次将⼀个待排序的记录按其关键字大小插⼊到前⾯已排好序的⼦序列中，直到全部记录插⼊完成。
## 2. 算法过程
![[img/08_排序/png/03 插入排序1.png]]
![[img/08_排序/png/04 插入排序2.png]]
![[img/08_排序/png/05 插入排序3.png]]
![[img/08_排序/png/06 插入排序4.png]]
![[img/08_排序/png/07 插入排序5.png]]
## 3. 算法实现
插入排序能够很明显地体现了递归思想，即每次插入其实都是在调用自己。
```c
// 直接插入排序
void InsertSort(int A[]; int n){
    int i, j, temp;
    for (i = 1; i < n; i++){    // 外层循环,逐个遍历
        if (A[i] < A[i-1]){     // A[i] 小于前驱
            temp = A[i];        // A[i] 缓存进temp内
            /*
            在前i-1个数中，从后往前追溯，一旦遇到不大于temp的立即停止
            表现为 出现比temp大的一直继续
            */
            for(j = i - 1; j >= 0 && A[j] > temp; --j){
                // 给temp 挪位置，原来的A[i] 被A[i-1]替换了，已经物是人非了
                A[j + 1] = A[j];    
            }
            // 把temp插到了它该存在的位置。
            A[j + 1] = temp;
        }
    }
}
```

如果使用带哨兵（sentinel）的方式，此时数组下标与位序一致。
```c
// 直接插入排序
void InsertSort(int A[]; int n){
    int i, j;
    // 外层循环,逐个遍历
    for(i = 2; i <= n; i++){    
        if(A[i] < A[i-1]){
            // 用哨兵存储将要排序的大数
            A[0] = A[i];
            // 从后往前依次对比，直至遇到 A[0] >= A[j]
            for(j = i - 1; A[0] < A[j]; --j){
            // 逐步后移    
                A[j + 1] = A[j];
            }
            // 在A[j] 后插入大数
            A[j + 1] = A[0];
        }    
    }
}
```
## 4. 算法性能分析
使用带哨兵的插入排序，优点即不用每轮都判断 `j >= 0`，运行效率略高一点。  
- 空间复杂度：$O(1)$  
- 时间复杂度：$O(N^2)$ 
    - 其中最好时间复杂度 $O(N)$ ，最坏时间复杂度$O(N^2)$  
    - 主要对比关键字、移动元素。若有 n 个元素，则需要 (n - 1) 趟。
- 算法稳定性：稳定排序

## 5. 算法优化
在插入时，将原来的遍历插入改变成折半插入。即在找寻插入位置的时候，采用二分查找。  
思路：先⽤二分查找找到应该插⼊的位置，再移动元素。

![[img/08_排序/png/08 折半插入 1.png]]
![[img/08_排序/png/09 折半插入 2.png]]

当 `low>high` 时折半查找停⽌，应将 `[low, i - 1]`内的元素全部右移，并将 `A[0]` 复制到 `low` 所指位置。

```c
// 折半插入查找，采用哨兵方式
void InsertSort(int A[],int n){
    int i, j, high, mid;
    // 外层循环,逐个遍历
    for (i = 2; i <= n; i++){
        A[0] = A[i];
        // 设置折半查找的范围
        low = 1; high = i - 1;
        // 折半查找范围限制
        while (low <= high){
            // 取半点
            mid = (low + high) / 2;
            // 查找左半 子表
            if (A[mid] > A[0]){
                high = mid -1;
            } 
            // 查找又半子表
            else{
                low = mid + 1;
            }
        }
        // 统一后移，空出插入位置
        for (j = i - 1; j > high + 1; --j){
            A[j + 1] = A[j];
        }
        // 在A[high]后插入完成
        A[high + 1] = A[0];
    }
}
```

采用二分查找插入，⽐起“直接插⼊排序”，⽐较关键字的次数减少了，但是移动元素的次数没变，整体来看时间复杂度依然是 $O(N^2)$ 。
对链表这类数据结构进⾏插⼊排序：只能通过直接插入，因为链表不具备随机存取特点，无法进行二分查找。

虽然移动元素的次数变少了，但是关键字对⽐的次数依然是 $O(N^2)$ 数量级，整体来看时间复杂度依然是 $O(N^2)$ 。


# [85] 希尔排序（Shell Sort）
## 1. 算法思想
希尔排序：先追求表中元素部分有序，再逐渐逼近全局有序。

![[img/08_排序/png/10 希尔排序 1.png]]

对于插入排序而言，如果原本的表中元素基本有序的话，那采用直接插入排序会达到一个相应不错的效率。  

具体方法：先将待排序表分割成若干形如 $L[ i, i + d, i + 2d,…, i + kd ]$ 的“特殊”⼦表，对各个⼦表分别进⾏直接插⼊排序。缩⼩增量 $d$，重复上述过程，直到 $d = 1$ 为⽌。

## 2. 算法过程

![[img/08_排序/png/11 希尔排序 2.png]]
![[img/08_排序/png/12 希尔排序 3.png]]
![[img/08_排序/png/13 希尔排序 4.png]]

## 3. 算法实现
以`{'49','38','65','97','76','13','27','49'}`表排序为例。
```c
// 希尔排序
void shellSort(int A[],int n){
    // d是元素的增量，
    int d, i, j;
    // A[0]是暂存单元，不是哨兵，当j <= 0时,插入位置已到
    for(d = n/2; d >= 1; d = d/2){      // 控制步长
        for (i = d + 1; i <= n; ++i){
            if (A[i] <= A[i-d]){        // 需要将A[i]插入有序增量子表
                A[0] = A[i];            // 暂存在A[0]
                for(j= i-d;j>0&& A[0]<A[j]; j-=d){
                    A[j+d] = A[j];      // 记录后移
                }
                A[j+d] = A[0];          // 插入
            }
        }
    }
}
```

动画演示：
![[img/08_排序/png/14 希尔排序 代码实现1.png]]
![[img/08_排序/png/15 希尔排序 代码实现2.png]]
![[img/08_排序/png/16 希尔排序 代码实现3.png]]
![[img/08_排序/png/17 希尔排序 代码实现4.png]]
![[img/08_排序/png/18 希尔排序 代码实现5.png]]
![[img/08_排序/png/19 希尔排序 代码实现6.png]]
![[img/08_排序/png/20 希尔排序 代码实现7.png]]

![[img/08_排序/png/21 希尔排序 代码实现8.png]]
![[img/08_排序/png/22 希尔排序 代码实现9.png]]
![[img/08_排序/png/23 希尔排序 代码实现10.png]]

## 4. 算法性能分析
- 空间复杂度： $O(1)$
- 时间间复杂度：和增量序列 $d_1, d_2, d_3…$ 的选择有关，⽬前⽆法⽤数学⼿段证明确切的时间复杂度。
  - 最坏时间复杂度为 $O(N^2)$ ，当 $n$ 在某个范围内时，可达 $O(N^{1.3})$
- 稳定性：不稳定的排序算法
- 适⽤性：仅适⽤于顺序表，不适⽤于链表。

