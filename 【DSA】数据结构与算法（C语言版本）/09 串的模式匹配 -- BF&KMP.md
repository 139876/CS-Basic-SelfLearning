#数据结构  #算法  #C 

# [36] 朴素模式匹配算法
## 字符串模式匹配 
在主串（被搜索的串）中找到与模式串（需要寻找的目标串）相同的⼦串，并返回其所在位置。  
通常最容易想到的方法，就是使用**暴力求解**。

如果主串⻓度为 `n`，模式串⻓度为 `m` 。  

## 朴素模式匹配算法（BruteForce）  
将长度为`n`主串中所有⻓度为`m`的⼦串依次与模式串对⽐，直到找到⼀个完全匹配的⼦串，或所有的⼦串都不匹配为⽌。这一过程，最多对⽐ `n - m + 1` 个⼦串。
[串](08%20串.md)中的函数`Index(S, T)`即是模式匹配算法的实现。

## 算法实现步骤
以下，不使⽤字符串的基本操作，直接通过数组下标实现朴素模式匹配算法。
具体分中间过程的匹配失败：
- 当指针小于主串和模式串字符串长度，启动逐个字符匹配
- 如果有字符相等，继续比较后续字符串
- 一旦出现字符不相等，匹配失败，主串指针 pStr 指向起初匹配⼦串的第⼀个位置的次一个，模式串指针 pPat 回到模式串的第⼀个位置，在这个基础上继续进行逐个字符匹配
- 完成退出循环时，比较模式串的指针的位置，确定匹配结果

![](img/04_串/08%20朴素模式匹配算法%20匹配失败.jpg)

![](img/04_串/09%20朴素模式匹配算法%20步数分析.jpg)

和匹配成功：

![](img/04_串/10%20朴素模式匹配算法%20匹配成功.jpg)
```c
int Index (StaticString S, StaticString T)
{
    // 设置两个扫描指针，分别指向主串 String 和模式串 Pattern
    int pStr = 1, pPat = 1;
    
    // 必须满足指针小于字符串长度，否则比较无意义。
    while (pStr <= S.length && pPat <= T.length) {
        // 如果有字符相等，继续比较后续字符串
        if (S.ch[pStr] == T.ch[pPat]) {
            ++pStr;
            ++pPat;  
        /* 一旦出现字符不相等，匹配失败
           主串指针 pStr 指向下⼀个⼦串的第⼀个位置，
           模式串指针 pPat 回到模式串的第⼀个位置, 指针后退重新开始匹配     
         */
        } else {
            pStr = pStr - pPat + 2;
            pPat = 1;
        }               
    }

    /* 退出循环的时候可能是有以下情况：
    1. pStr > S.length, S已经完全扫描完, 遍历结束也没有匹配
    2. pPat > T.length, T已经完全扫描完, S还未完全遍历已匹配
    对于情况1 和2, 需要判定究竟是哪一类
    对 pPat 的值进行检验 ( 对s的值检验无效，是否匹配均有可能 )
    */
    if (pPat > T.length) {
        return pStr - T.length;
    } else {
        return 0;
    }
}
```
## 算法评价
设主串⻓度为 $n$，模式串⻓度为 $m$，则：  
**最坏时间复杂度** = $O(nm)$  
**最好时间复杂度** = $O(N)$  
推导：
- **最坏的情况**：  
  每个⼦串都要对⽐ $m$ 个字符，共 $n-m+1$ 个⼦串，  
  复杂度 = $O((n - m + 1) * m)$ = $O(nm)$  
  注：很多时候，n >> m
- **最好的情况**：  
  每个⼦串的第⼀个字符就匹配失败，共 $n-m+1$ 个⼦串  
  复杂度 = $O(n - m + 1)$ = $O(N)$



# [37]   KMP算法
由D.E.Knuth，J.H.Morris和V.R.Pratt提出，因此称为 KMP算法，该算法对朴素模式匹配算法优化而得。

[FAST PATTERN MATCHING IN STRINGS_1977.pdf (ufpe.br)](https://www.cin.ufpe.br/~paguso/courses/if767/bib/KMP_1977.pdf)


## 1. 场景复现
**场景**：
已知模式串 `T`,`S` , 循环中，遍历串字符，当第i（i > 1）个元素匹配失败时,第 i 个元素之前的元素是已经匹配成功的。

![](img/04_串/11%20子串匹配%20匹配失败.jpg)

对于朴素模式匹配算法而言，这些已经匹配成功的字符将会被直接舍去。
如何对该算法进行优化？
#未完待续

![](img/04_串/46%20模式匹配算法优化.png)

对于已知模式串 T = ‘abaabc’，主串的元素是未知的。对**适配情况进行列举**： 
- 当**第6个**元素匹配失败时，可令主串指针 i **不变**，模式串指针 `j=3` 
- 当**第5个**元素匹配失败时，可令主串指针 i **不变**，模式串指针`j=2` 
- 当**第4个**元素匹配失败时，可令主串指针 i **不变**，模式串指针 `j=2` 
- 当**第3个**元素匹配失败时，可令主串指针 i **不变**，模式串指针`j=1` 
- 当**第2个**元素匹配失败时，可令主串指针 i **不变**，模式串指针 `j=1` 
- 当**第1个**元素匹配失败时，**匹配下⼀个相邻⼦串**，令 `j=0, i++, j++;`

## 2. 算法优化
下面以主串`S = "abaacaabcabaabc"`，模式串`T="abaabc"`为例。使用优化后的算法进行字符串匹配：

![](img/04_串/47%20KMP优化1.png)
![](img/04_串/48%20KMP优化2.png)
![](img/04_串/49%20KMP优化3.png)

![](img/04_串/50%20KMP优化4.png)
![](img/04_串/51%20KMP优化5.png)

![](img/04_串/52%20KMP优化6.png)
![](img/04_串/53%20KMP优化7.png)

进行匹配过程中，**主串指针不回溯**。  
下一步，如何确定匹配过程失败时候，主串指针的位置？  
解决方式：利用穷举方式，将主串匹配失败i位置与模式串指针j位置建立数组。称之为`next`数组。

![](img/04_串/54%20next数组.png)

当匹配失败过程时，`i`指针从未往前回溯，`next`数组指明`j`指针的下个位置。

## 3. 程序实现
**总结**：KMP算法，根据模式串`T`，求出 `next` 数组，利⽤`next`数组进⾏匹配,`next`数组只和短的模式串有关，和⻓的主串⽆关。

```c
// KMP算法实现
int Index_KMP(StaticString S, StaticString T, int next[]){
    int i = 1, j = 1;
    while(i <= S.length && j <= T.length){
        if(j==0 || S.ch[i] == T.ch[j]){
            ++i;
            ++j;            // 继续比较后继字符
        } else {
            j = next[j];    // 模式串向右移动
        }
    }
    if(j > T.length){
        return i - T.length;
    } else {
        return 0;
    }
}
```
## 4. 算法评价
最坏时间复杂度 $O(m + n)$  
其中，求 `next` 数组时间复杂度 $O(m)$  
模式匹配过程最坏时间复杂度 $O(N)$  

# [38] 求KMP算法的`next`数组
根据模式串`T`，求出 `next` 数组。  
**`next`数组的作⽤**：**当模式串的第 j 个字符失配时，从模式串的第** `next[j]` **的继续往后匹配。**  
**问题**：现在求`next`数组的具体元素是多少，以模式串`"google"`为例。

![](img/04_串/55%20求next数组.png)

## 1. 求`next[1]`的值
任何模式串都⼀样，第1个字符不匹配时，只能匹配下⼀个⼦串，因此，往后，`next[1]`都⽆脑写 0。然后再继续执行以下程序：
```c
if (j == 0) { 
    i++; 
    j++; }
```

![](img/04_串/56%20next[1].png)

## 2. 求`next[2]`的值
任何模式串都⼀样，第2个字符不匹配时，应尝试匹配模式串的第1个字符，因此，往后，`next[2]`都⽆脑写 1。

![](img/04_串/57%20next[2].png)

## 3. 求`next[3]`的值
在不匹配的位置前边，**划⼀根分界线**，模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为⽌。   
此时 `j` 指向哪⼉，`next`数组值就是多少。
对于模式串`"google"`，`next[3]` = 1。

![](img/04_串/58%20next[3].png)

## 4. 求`next[4]`的值
在不匹配的位置前边，**划⼀根分界线**，模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为⽌。 
此时 `j` 指向哪⼉，`next`数组值就是多少。
对于模式串`"google"`，`next[4]` = 1。

![](img/04_串/59%20next[4].png)

## 5. 求`next[5]`的值
在不匹配的位置前边，**划⼀根分界线**，模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为⽌。   
此时 `j` 指向哪⼉，`next`数组值就是多少。
对于模式串`"google"`，`next[5]` = 2。

![](img/04_串/60%20next[5].png)

## 6. 求`next[6]`的值
在不匹配的位置前边，**划⼀根分界线**，模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为⽌。 
此时 `j` 指向哪⼉，`next`数组值就是多少。
对于模式串`"google"`，`next[6]` = 1。

![](img/04_串/61%20next[6].png)

## 7. 总结
`next[1] = 0` ，`next[2] = 1` 。   
其他 `next[i]`：在不匹配的位置前，划⼀根分界线；模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为止。此时 `j` 指向哪⼉，`next`数组值就是多少。

程序实现：
```c
void getNext(char *p, int len, int next[])
{
    next[0] = -1;
    int k = -1;
    int j = 0;
    while(j < len - 1)
    {
        if(k == -1 || p[j] == p[k])
        {
            ++j;
            ++k;
            next[j] = k;
        }
        else
        {
            k = next[k];
        }
    }
}
```

参考链接：
[KMP算法中next数组的求法及代码实现【C++】 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/159429201)
