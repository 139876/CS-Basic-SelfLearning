#数据结构 #算法 
# [80] 快速排序
“快速排序”是交换排序的另一种。
### 1. 算法思想
在待排序表 $L[1…n]$ 中任取⼀个元素pivot作为枢轴（或基准，通常取⾸元素），通过⼀趟排序将待排序表划分为独⽴的两部分$L[1…k-1]$和$L[k+1…n]$，使得$L[1…k-1]$中的所有元素⼩于pivot，$L[k+1…n]$中的所有元素⼤于等于pivot，则pivot放在了其最终位置$L(k)$上，这个过程称为⼀次“划分”。然后分别递归地对两个⼦表重复上述过程，直⾄
每部分内只有⼀个元素或空为⽌，即所有元素放在了其最终位置上。
### 2. 算法过程
以数组A`{49,38,65,97,76,13,27,49}`为例，以递归工作栈的方式来实现快速排序。
把最起初的数字`A[0]`的值49作为中枢，即基准。
![[img/09 排序/31 快速排序 第一层1.png]]
![[img/09 排序/32 快速排序 第一层2.png]]
![[img/09 排序/33 快速排序 第一层3.png]]
以pivot为中枢，对其他元素按照大小值，小于pivot的放于左侧，大于pivot的放于右侧。然后将pivot填入其中。
进入下一层递归：
![[img/09 排序/34 快速排序 第二层 1.png]]

![[img/09 排序/35 快速排序 第二层 2.png]]
![[img/09 排序/36 快速排序 第三层 1.png]]
![[img/09 排序/37 快速排序 第三层 2.png]]
![[img/09 排序/38 快速排序 第三层 3.png]]
![[img/09 排序/39 快速排序第三层 5.png]]


![[img/09 排序/40 快速排序回溯 空栈.png]]


### 3. 算法实现
```c
// 用第一个元素将待排序序列划分分为左右两个部分
int Partition(int A[], int low, int high){
    // 把第一个元素当作枢轴
    int pivot = A[low];             
    // 用low、high搜索枢轴的最终位置，
    // 当low与high相碰的时候和或者 low溢出high的时候 结束
    while (low < high){
        // 比枢轴小的元素移动到左端
        while (low < high && A[high] >= pivot){
            --high;
        }
        A [low] = A [high];
        // 比枢轴大的元素移动到右端
        while (low < high && A[low] <= pivot){
            ++low;
        }
        A[high] = A[low];
    }
    // 返回存放枢轴的最终位置
    A[low] = pivot;             
}

// 快速排序
void QuickSort(int A[], int low, int high){
    if (low < high){                            // 递归跳出条件
        int pivotpos = Partition(A,low,high);   // 划分
        QuickSort(A, low, pivotops - 1);        // 划分左子表
        QuickSort(A, low, pivotops - 1);        // 划分右子表
    }
}
```
每⼀层的`QuickSort` 只需要处理剩余的待排序元素，时间复杂度不超过$O(N)$

### 4. 算法性能
把n个元素组织成⼆叉树，⼆叉树的层数就是递归调⽤的层数
n个结点的⼆叉树最⼩⾼度 = $⌊log2n⌋ + 1$，最⼤⾼度 = $n$
![[img/09 排序/42 快速排序  二叉树转化.png]]
- **特殊情形下的快速排序**：
    若每⼀次选中的“枢轴”将待排序序列划分为很不均匀的两个部分，则会导致递归深度增加，算法效率变低。
    若初始序列有序或逆序，则快速排序的性能最差（因为每次选择的都是最靠边的元素）。
- ** 快速排序的优化**：
    尽量选择可以把数据中分的枢轴元素。
    eg：①选头、中、尾三个位置的元素，取中间值作为枢轴元素；②随机选⼀个元素作为枢轴元素。
- **综合对比**：
    快速排序是所有内部排序算法中**平均性能最优**的排序算法。
    时间复杂度=$O(n*递归层数)$，
        最好时间复杂度=$O(n\log_{2}{n})$，最坏时间复杂度=$O(N^2)$，平均时间复杂度=$O(n\log_{2}{n})$
    空间复杂度=$O(递归层数)$，
        最好空间复杂度=$O(\log_{2}{n})$，最坏时间复杂度=$O(N)$。
    快速排序是不稳定的排序。

## [81]     简单选择排序
选择排序：每⼀趟在待排序元素中选取关键字最⼩（或最⼤）的元素加⼊有序⼦序列。
其中，选择排序又分为——**简单选择排序**和**堆排序**。
### 1. 算法思想
每⼀趟在待排序元素中选取关键字最⼩的元素加⼊有序⼦序列
### 2. 算法过程
以数组A`{49,38,65,97,76,13,27,49}`为例，对n个元素的简单选择排序需要 n-1 趟处理。
![[img/09 排序/43 简单选择排序.png]]
![[img/09 排序/44 简单选择排序.png]]
![[img/09 排序/45 简单选择排序.png]]
![[img/09 排序/46 简单选择排序.png]]
### 3. 算法实现
```c
void swap(int &a, int &b){
     int temp = a;
     a = b;
     b = temp; 
}

void SelectSort(int A[],int n){
    // 一共进行 n-1 趟, i指代待排序的元素开头位置
    for (int i =0; i < n - 1; i++){
        // 记录最小元素位置
        int min = i;
        // 在 A[i, n-1]中找最小的元素
        for (int j = i + 1; j < n; j++){
            // 更新最小的元素
            if (A[j] < A[min]){
                min = j;
            }
        }

        if (min != i){
            swap(A[i], A[min]);
        }
    }
}
```
### 4. 算法性能
⽆论有序、逆序、还是乱序，⼀定需要 n-1 趟处理
总共需要对⽐关键字$(n-1) + (n-2)+ … + 1 = \frac{n(n-1)}{2}$次，元素交换次数 < $n-1$
时间复杂度 = $O(N^2)$
空间复杂度 = $O(1)$

## [82]     堆排序
### 1. 什么是“堆”数据结构
若$n$个关键字序列$L[1…n]$满⾜下⾯某⼀条性质，则称为堆（Heap）：
① 若满⾜：$L(i)≥L(2i)$且$L(i)≥L(2i+1)$ $(1 ≤ i ≤n/2 )$—— ⼤根堆（大顶堆）
② 若满⾜：$L(i)≤L(2i)$且$L(i)≤L(2i+1) (1 ≤ i ≤n/2)$—— ⼩根堆（小顶堆）
### 2. 算法思想
思路：把所有⾮终端结点都检查⼀遍，是否满⾜⼤根堆的要求，如果不满足，则进⾏调整⼤根堆，若元素互换破坏了下⼀级的堆，则采⽤相同的⽅法继续往下调整（小元素不断“下坠”）。
### 2. 算法过程

### 3. 算法实现
```c
// 建立大根堆
void BuildMaxHeap(int A[], int len){
    // 从后往前调整所有非终端结点
    for (int i = len / 2; i > 0; i--){
        HeadAdjust(A, i, len);
    }
}

// 将以k为根的子树调整为大根堆
void HeadAdjust(int A[], int k, int len){
    // A[0] 暂存子树的根节点
    A[0] = A[k];
    // 沿key较大的子节点向下筛选
    for (int i = 2 * k; i < len; i *= 2){
        // 取key较大的子节点的下标
        if (i < len && A[i] < A[i + 1]){
            i++;
        }
        // 筛选结束
        if (A[0] >= A[i]) {
            break;
        }
        // 将A[i] 调整到双亲结点上
        // 修改k值, 以便继续向下筛选
        else {
            A[k] = A[i];
            k = i;
        }
    }
    A[k] = A[0];
}
```
### 4. 算法性能

## [83]     堆的插入删除
对于小根堆，新元素放到表尾，与父节点对比，若新元素比父节点更小，则将二者互换。新元素就这样一路"上升"，直到无法继续上升为止。

被删除的元素用堆底元素替代，然后让该元素不断"下坠"，直到无法下坠为止。


## [84]     归并排序(Merge Sort)
### 1. 算法思想
将多个已经有序的序列合并成一整个有序序列。

### 2. 算法过程
对比i，j所指元素，选择一个更小的放入到k所指的位置（使用双指针法）。

当只剩下一个子表未合并的时候，可以将该表剩下升序的其他元素全部加到总表之中。
核心操作：把数组当中内部的两个有序序列归并成一个。

### 3. 算法实现
```c
// 辅助数组B
int *B = (int*) malloc (n*sizeof(int));

// A[low, mid] 和A[mid+1, high]各自有序，将两个部分归并
void Merge (int A[], int low, int mid, int high){
    int i, j, k;
    for (k= low; k<=high; k++){
        B[k] = A[k];
    }
    // 将A中所有的元素复制到B中
    for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++){
        if (B[i] <= B[j]){
            A[k] = B[i++];
        } else {
            A[k] = B[j++];
        }
    }
    while (i <= mid){
        A[k++] = B[i++];
    }
    while (j <= high){
        A[k++] = B[i++];
    }
}

void MergeSort(int A[], int low, int high){
    if (low < high){
        int mid = (low + high) / 2;
        MergeSort(A, low, mid);
        MergeSort(A, mid + 1, high);
        MergeSort(A, low, mid, high);
    }
}
```

## [85]     基数排序(Radix Sort)



## [86]     外部排序
外存和内存之间是怎样进行数据交换的？
操作系统以“块”为单位对磁盘存储空间进行管理，如:每块大小1KB。各个磁盘块内存放着各种各样的数据。
使用归并排序的方式，最少只需要在内存中分配 3块 大小的缓冲区，即可对任意一个大文件进行排序。


## [87]     败者树

## [88]     置换选择排序

## [89]     最佳归并树