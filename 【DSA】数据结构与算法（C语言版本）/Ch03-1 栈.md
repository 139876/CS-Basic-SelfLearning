#数据结构 
# 栈
# [21] 栈的基本概念
栈（Stack）是**只允许在一端进行插入或删除**操作的线性表。

- 逻辑结构：与普通线性表相同 
- 数据的运算：插入、删除操作有区别

重要术语：**栈顶、栈底、空栈**。
- **栈顶**：允许插入 和删除的一端
- **栈底**：不允许插 入和删除的一端

![](img/03_栈与队列/01%20栈.JPG)
特点：后进先出 / Last In First Out （**LIFO**）

```cpp
// 初始化栈。构造一个空栈 S，分配内存空间。
InitStack(&S);
// 销毁栈。销毁并释放栈 S 所占用的内存空间。 
DestroyStack(&S);

// 进栈，若栈S未满，则将x加入使之成为新栈顶。 
Push(&S,x);
// 出栈，若栈S非空，则弹出栈顶元素，并用x返回。 
元素的进栈和出栈，只能再栈顶进行操作。
Pop(&S,&x);

// 读栈顶元素。若栈 S 非空，则用 x 返回栈顶元素 
GetTop(S, &x);

其他常用操作： 
// 判断一个栈 S 是否为空。若S为空，则返回true，否则返回false
StackEmpty(S);
```

问：如果有n个不同元素进栈，出栈元素不同排列的个数为:
$$\frac{1}{n+1}C_{2n}^{n}$$
上述公式称为**卡特兰（Catalan）数**，可采用数学归纳法证明（不要求掌握）。  
这里可以涉及一道算法题目：  
[946. 验证栈序列 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-stack-sequences/description/)

# [22] 栈的顺序存储结构
对于栈的定义，首先使用顺序表存储栈结构，使用结构体变量，包含数据部分和栈顶指针（**永远指向栈的栈顶位置**）。
## 1. 顺序栈定义
```c
#define MaxSize 10              // 定义栈元素中的最大个数
typedef struct {
    ElemType data[MaxSize];     // 静态数组中存放栈
    int top;                    // 栈顶指针
} SqStack;

void testStack()
{
    SqStack S;                  // 声明一个顺序栈（分配空间）
    /* ...后续操作... */
}
```

![](img/03_栈与队列/02%20顺序栈.JPG)

## 2. 初始化栈
指定栈顶指针为-1，一个没有实际意义的数字，用来表示是一个空栈。
```c
#define MaxSize 10              // 定义栈元素中的最大个数
type struct{
    ElemType data[MaxSize];     // 静态数组中存放栈
    int top;                    // 栈顶指针
} SqStack;

// 初始化栈
void InitStack(SqStack &S)
{
    S.top = -1;                 // 初始化栈顶指针
}

void testStack(SqStack &S)
{
    SqStack S;
    InitStact(S);
    /* 后续操作 */
}
```

## 3. 如何判断栈是空？
同理，判断栈顶指针是否是 -1 即可。
```c
// 对栈判空
bool StackEmpty(SqStack S)
{
    if (S.top = -1) {
        return true;
    } else {
        return false;    
    }
}
```

## 4. 进栈操作，在栈顶添加数据

![](img/03_栈与队列/03%20入栈.JPG)

```c
// 进栈
bool Push(SqStack &S, ElemType x)
{
    if (S.top == MaxSize - 1) {    // 栈满，报错
        return false;
    }
    S.top++;                    // 栈顶指针自增1
    S.data[S.top] = x;          // 新元素入栈
    /*  上面两句可以等价写成:
        S.data[++S.top] = x 
        注意先移动指针，再赋值的顺序 */
    return true;
}
```

## 5. 出栈操作

![](img/03_栈与队列/04%20出栈.JPG)

```c
// 出栈
bool Pop(SqStack &S, ElemType &x)
{
    if (S.top == -1) {
        return false;
    }
    x = S.data[S.top];          // 栈顶元素先出栈
    S.top--;                    // 栈顶指针自减1
    /*  上面两句可以等价写成:
    x == S.data[S.top--] 
    注意先传递数值，再移动指针 */
    return true;
}
```

## 6. 读取栈顶元素操作
直接根据索引，查询索引值。
```c
// 读取栈顶元素
bool Pop(SqStack &S, ElemType &x)
{
    if (S.top == -1) {
        return false;
    }
    x = S.data[S.top];          // 用x记录栈顶元素
    return true;
}
```

## 7. 共享栈
共享栈是一种特殊的栈，使用相同的一片内存空间，使用两个栈共存。内存空间的两个边界分别作为两个栈的栈底，同时，因此也有两个栈顶指针。而共享栈数据的生长，沿着彼此相对的方向。
```c
// 共享栈的由一块内存的首位各定义了一个栈顶
#define MaxSize 10              // 定义栈元素中的最大个数
type struct{
    ElemType data[MaxSize];     // 静态数组中存放栈
    int top_0;                   // 0号栈顶指针
    int top_1;                   // 1号栈顶指针
} SqStack;

void InitStack(ShStack &S)
{
    S.top_0 = -1;
    S.top_1 = MaxSize;           // 两栈从两头分别进行存储
}

// 栈满的条件： top_1 == top_0 + 1
```

![](img/03_栈与队列/05%20共享栈，双向生长.JPG)

# [23] 栈的链式存储结构 
用链式存储的方式实现的栈称之为链栈（LinkedList Stack）。
如果规定**对只能在单链表表头一侧**进行操作，那么用头插法建立单链表，实质上就是进栈操作; 

![](img/03_栈与队列/06%20链栈-入栈.jpg)

用头插法删除单链表，实质上就是出栈操作。

![](img/03_栈与队列/07%20链栈-出栈.jpg)

原来的链头，即是栈的栈顶。

```c
// 定义链栈
typedef struct Linknode{
    ElemType data;
    struct Linknode *next;
} *LiStack;
```
由于链式存储的栈实际的操作跟链表类似。具体情况不再做过多讨论。
