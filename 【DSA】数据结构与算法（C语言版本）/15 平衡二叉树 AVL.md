#数据结构 #C 

# [53]     平衡二叉树
平衡二叉树（Balanced Binary Tree），简称平衡树（AVL树）—— 树上任一结点的左子树和右子树的高度之差不超过1。
`结点的平衡因子 = 左子树高 - 右子树高`
G. M. Adelson-Velsky和E. M. Landis 于1962年发明。
![[img/06_树2/58 AVL.png]]
平衡二叉树结点的平衡因子的值只可能是−1、0或1。
只要有任一结点的平衡因子绝对值大于1，就不是平衡二叉树。
```c
// 平衡二叉树结点
typedef struct AVLNode
{
    int key;            // 数据域
    int balance;        // 平衡因子
    struct AVLNode *lchild, *rchild;
} AVLNode, *AVLTree;
```
## 1. AVL的插入
![[img/06_树2/59 AVL 插入.png]]
在二叉排序树中插入新结点后，查找路径上的所有结点都有可能受到影响，从插入点往回
找到第一个不平衡结点，调整以该结点为根的子树。
上图中，以70为根节点的子树，即是“最小不平衡子树”。
![[img/06_树2/60 调整不平衡子树.png]]

分析得出，调整最小不平衡子树，有以下四种情况：
- 在A的**左孩子**的**左子树**中插入导致不平衡（LL）；
- 在A的**右孩子**的**右子树**中插入导致不平衡（RR）；
- 在A的**左孩子**的**右子树**中插入导致不平衡（LR）；
- 在A的**右孩子**的**左子树**中插入导致不平衡（RL）；

## 2. 调整最小不平衡子树（LL）
如图，使用方框代表一个抽象的子树，高度为H。经过`LL`型插入后左孩子的左子树高度变成了`H+1`。这个时候A的平衡因子由1变成2，导致了不平衡。

![[img/06_树2/61 LL不平衡子树.png]]

在这里使用三个抽象树都是高度H，原因是因为，这里刚好设置的高度满足，LL插入后可以立即形成一个最小不平衡树，可以举例AR的高度是`H+1`试一试即可证明。

【调整方法】**LL平衡旋转**（**右单旋转**）。
二叉排序树的特性：左子树结点值 < 根结点值 < 右子树结点值，所以：`BL<B<BR<A<AR`。
由于在结点A的左孩子（L）的左子树（L）上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作。
将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。

![[img/06_树2/62 LL不平衡子树右旋.png]]

代码实现：
```c
// 假设A的父结点指针是gf，A的结点指针是f，B的结点指针是p。
f->lchild = p->rchild;      // 把BR变成AL
p->rchild = f;              // A成B的右子树
gf->lchild/rchild = p;      // B变成gf的子树
```

## 3. 调整最小不平衡子树（RR）
【调整方法】RR平衡旋转（左单旋转）。

![[img/06_树2/63 RR不平衡子树.png]]

由于在结点A的右孩子（R）的右子树（R）上插入了新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。
将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树。

![[img/06_树2/64 RR不平衡子树左旋.png]]

代码实现：
```c
// 假设A的父结点指针是gf，A的结点指针是f，B的结点指针是p。
f->rchild = p->lchild;      // 把BL变成AR
p->rchild = f;              // A成B的右子树
gf->lchild/rchild = p;      // B变成gf的子树
```

## 4. 调整最小不平衡子树（LR）
【调整方法】**LR平衡旋转**（先左后右双旋转）。
![[img/06_树2/65 LR不平衡子树.png]]
由于在A的左孩子（L）的右子树（R）上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。
1. 先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，
2. 然后再把该C结点向右上旋转提升到A结点的位置。
图中以插入结点在C的右子树CR中，等量换做到CL上依然可以按照相同方法保证调整成功。
![[img/06_树2/66 LR不平衡子树调整.png]]
## 4. 调整最小不平衡子树（LR）
【调整方法】**RL平衡旋转**（先右后左双旋转）。
由于在A的右孩子（R）的左子树（L）上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先**右旋转后左旋转**。
![[img/06_树2/67 RL不平衡子树.png]]
1. 先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置；
2. 然后再把该C结点向左上旋转提升到A结点的位置。
图中以插入结点在C的左子树CL中，等量换做到CH上依然可以按照相同方法保证调整成功。
![[img/06_树2/68 RL不平衡子树调整.png]]

总结只有左孩子才能右上旋，右孩子才能左旋。每次旋转都会导致孩子成为父亲，父亲成为孩子。

在插入结点中，只要将**最小不平衡子树调整平衡**，则其他祖先结点都会恢复平衡。操作导致“最小不平衡子树”高度+1，经过调整后高度恢复。

若树高为h，则最坏情况下，查找一个关键字最多需要对比 h 次，即查找操作的时间复杂度不可能
超过 $O(h)$。
平衡二叉树——树上任一结点的左子树和右子树的高度之差不超过1。
假设以$n_h$表示深度为h的平衡树中含有的最少结点数。
则有$n_0= 0, n_1 = 1, n_2 = 2$，并且有：$$n_h = n_{h−1} + n_{h−2} + 1.$$
可以证明含有n个结点的平衡二叉树的最大深度为$O(log_2n)$，平衡二叉树的平均查找长度为$O(log_2n)$。

# [54]     哈夫曼树
结点的权：有某种现实含义的数值（如：表示结点的重要性等）。
结点的带权路径长度：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积。
树的带权路径长度：树中所有叶结点的带权路径长度之和（WPL, Weighted Path Length）。
$$WPL = \sum_{i=1}^n W_i l_i$$

![[img/06_树2/69 哈夫曼树.png]]
在含有n个带权叶结点的二叉树中，其中**带权路径长度（WPL）最小的二叉树称为哈夫曼树**，也称**最优二叉树**。如果中下方的两个二叉树中，均属于哈夫曼树（Huffman Tree）。

## 1. 哈夫曼树构造
给定n个权值分别为$w_1, w_2,…, w_n$的结点，构造哈夫曼树的算法描述如下：
1. 将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林`F`。
2. 构造一个新结点，从`F`中选取**两棵根结点权值最小**的树作为新结点的左、右子树，并且将新
结点的权值置为左、右子树上根结点的权值之和。
3. 从`F`中删除刚才选出的两棵树，同时将新得到的树加入`F`中。
4. 重复步骤（2）和（3），直至`F`中只剩下一棵树为止。
![[img/06_树2/70 哈夫曼树构造.png]]
特点：
1. 每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大
2. 哈夫曼树的结点总数为2n − 1
3. 哈夫曼树中不存在度为1的结点。
4. 哈夫曼树并不唯一，但WPL必然相同且为最优。
![[img/06_树2/71 哈夫曼树构造.png]]

## 2. 哈夫曼编码
**可变长度编码**——允许对不同字符用不等长的二进制位表示。
若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。
假设，100题中有80题选C，10题选A，8题选B，2题选D，如果用0，1 编码这些信息，如果使用平均使用，所有答案的二进制长度=$80*2+10*2+8*2+2*2=200$ bit。
![[img/06_树2/72 哈夫曼编码.png]]
使用哈夫曼编码，即右侧的，将使用信息：$WPL= 80*1+10*2+2*3+8*3=130$bit。
有哈夫曼树得到哈夫曼编码——字符集中的每个字符作为一个叶子结点，各个字符出现的频度作为结点的权值，根据之前介绍的方法构造哈夫曼树。
哈夫曼编码使用的方式，降低二进制编码的数量，因此哈夫曼编码可用于数据压缩。