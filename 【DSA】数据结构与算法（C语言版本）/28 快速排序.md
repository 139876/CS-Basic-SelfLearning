#数据结构 #算法 #C
# [86] 快速排序
“快速排序”是交换排序的另一种。
## 1. 算法思想
在待排序表 $L[1, … n]$ 中任取⼀个元素`pivot`作为枢轴（或基准，通常取⾸元素），通过⼀趟排序将待排序表划分为独⽴的两部分: 
$$L[1, … k - 1]$$
和
$$L[k + 1, … n]$$
使得:  
- $L[1,…k-1]$ 中的所有元素⼩于`pivot`，  
- $L[k+1,…n]$中的所有元素⼤于等于`pivot`，  

则`pivot`放在了其最终位置 $L(k)$ 上，这个过程称为⼀次“划分”。
然后分别递归地对两个⼦表重复上述过程，直⾄每部分内只有⼀个元素或空为⽌，即所有元素放在了其最终位置上。
## 2. 算法过程
以数组A`{49,38,65,97,76,13,27,49}`为例，以递归工作栈的方式来实现快速排序。
把最起初的数字`A[0]`的值49作为中枢，即基准。

![[img/08_排序/png/31 快速排序 第一层1.png]]
![[img/08_排序/png/32 快速排序 第一层2.png]]
![[img/08_排序/png/33 快速排序 第一层3.png]]

以pivot为中枢，对其他元素按照大小值，小于pivot的放于左侧，大于pivot的放于右侧。然后将pivot填入其中。
进入下一层递归：

![[img/08_排序/png/34 快速排序 第二层 1.png]]

![[img/08_排序/png/35 快速排序 第二层 2.png]]
![[img/08_排序/png/36 快速排序 第三层 1.png]]
![[img/08_排序/png/37 快速排序 第三层 2.png]]
![[img/08_排序/png/38 快速排序 第三层 3.png]]
![[img/08_排序/png/39 快速排序第三层 5.png]]


![[img/08_排序/png/40 快速排序回溯 空栈.png]]


## 3. 算法实现
```c
// 用第一个元素将待排序序列划分分为左右两个部分
int Partition(int A[], int low, int high){
    // 把第一个元素当作枢轴
    int pivot = A[low];             
    // 用low、high搜索枢轴的最终位置，
    // 当low与high相碰的时候和或者 low溢出high的时候 结束
    while (low < high){
        // 比枢轴小的元素移动到左端
        while (low < high && A[high] >= pivot){
            --high;
        }
        A [low] = A [high];
        // 比枢轴大的元素移动到右端
        while (low < high && A[low] <= pivot){
            ++low;
        }
        A[high] = A[low];
    }
    // 返回存放枢轴的最终位置
    A[low] = pivot;             
}

// 快速排序
void QuickSort(int A[], int low, int high){
    if (low < high){                            // 递归跳出条件
        int pivotpos = Partition(A,low,high);   // 划分
        QuickSort(A, low, pivotops - 1);        // 划分左子表
        QuickSort(A, low, pivotops - 1);        // 划分右子表
    }
}
```
每⼀层的`QuickSort` 只需要处理剩余的待排序元素，时间复杂度不超过$O(N)$

## 4. 算法性能
把n个元素组织成⼆叉树，⼆叉树的层数就是递归调⽤的层数:  
- n个结点的⼆叉树最⼩⾼度 = $⌊log2n⌋ + 1$，
- 最⼤⾼度 = $n$


![[img/08_排序/png/42 快速排序  二叉树转化.png]]

**特殊情形下的快速排序**：  
    若每⼀次选中的“枢轴”将待排序序列划分为很不均匀的两个部分，则会导致递归深度增加，算法效率变低。
    若初始序列有序或逆序，则快速排序的性能最差（因为每次选择的都是最靠边的元素）。
- ** 快速排序的优化**：
    尽量选择可以把数据中分的枢轴元素。
    eg：①选头、中、尾三个位置的元素，取中间值作为枢轴元素；②随机选⼀个元素作为枢轴元素。
- **综合对比**：
    快速排序是所有内部排序算法中**平均性能最优**的排序算法。
    时间复杂度=$O(n*递归层数)$，
        最好时间复杂度=$O(n\log_{2}{n})$，最坏时间复杂度=$O(N^2)$，平均时间复杂度=$O(n\log_{2}{n})$
    空间复杂度=$O(递归层数)$，
        最好空间复杂度=$O(\log_{2}{n})$，最坏时间复杂度=$O(N)$。
    快速排序是不稳定的排序。


