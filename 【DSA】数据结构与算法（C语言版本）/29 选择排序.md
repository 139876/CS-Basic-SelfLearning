#数据结构 #算法 #C
# [87] 简单选择排序
选择排序：每⼀趟在待排序元素中选取关键字最⼩（或最⼤）的元素加入有序⼦序列。
其中，选择排序又分为——简单选择排序和堆排序。
### 1. 算法思想
每⼀趟在待排序元素中选取关键字最小的元素加⼊有序子序列
### 2. 算法过程
以数组A`{49,38,65,97,76,13,27,49}`为例，对n个元素的简单选择排序需要 n-1 趟处理。
![[img/08_排序/png/43 简单选择排序.png]]
![[img/08_排序/png/44 简单选择排序.png]]
![[img/08_排序/png/45 简单选择排序.png]]
![[img/08_排序/png/46 简单选择排序.png]]
### 3. 算法实现
```c
void swap(int &a, int &b){
     int temp = a;
     a = b;
     b = temp; 
}

void SelectSort(int A[],int n){
    // 一共进行 n-1 趟, i指代待排序的元素开头位置
    for (int i =0; i < n - 1; i++){
        // 记录最小元素位置
        int min = i;
        // 在 A[i, n-1]中找最小的元素
        for (int j = i + 1; j < n; j++){
            // 更新最小的元素
            if (A[j] < A[min]){
                min = j;
            }
        }

        if (min != i){
            swap(A[i], A[min]);
        }
    }
}
```
### 4. 算法性能
⽆论有序、逆序、还是乱序，⼀定需要 n-1 趟处理
总共需要对⽐关键字$(n-1) + (n-2)+ … + 1 = \frac{n(n-1)}{2}$次，元素交换次数 < $n-1$
时间复杂度 = $O(N^2)$
空间复杂度 = $O(1)$