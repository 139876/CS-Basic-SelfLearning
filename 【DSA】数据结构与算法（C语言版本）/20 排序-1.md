#数据结构 #算法

![[img/09 排序/00 排序算法总结.png]]
# [76] 排序基本概念

**排序**（Sort），就是重新排列表中的元素，使表中的元素满⾜按关键字有序的过程。  
**输⼊**： $n$  个记录 $R_1, R_2,…, R_n$ ，对应的关键字为 $k_1, k_2,…, k_n$ 。  
**输出**：输⼊序列的⼀个重排 $R_1ʹ, R_2ʹ,…, R_nʹ$，使得有 $k_1ʹ≤k_2ʹ≤…≤k_nʹ$ （也可递减）。  

算法的**稳定性**。若待排序表中有两个元素 $R_i$ 和 $R_j$ ，其对应的关键字相同即$key_i = key_j$，且在排序
前 $R_i$ 在 $R_j$ 的前⾯，若**使⽤某⼀排序算法排序后**，$R_i$仍然在$R_j$的前⾯，则称这个**排序算法是稳定
的**，否则称排序算法是不稳定的。
![[img/09 排序/01 排序的稳定性.png]]
**内部排序**：数据都在内存中，关注如何使算法时、空复杂度更低。
**外部排序**：数据太多，无法全部放入内存。还要关注如何使读/写磁盘次数更少。
![[img/09 排序/02 内部排序 VS 外部排序.png]]

# [77] 插入排序

### 1. 算法思想
每次将⼀个待排序的记录按其关键字⼤⼩插⼊到前⾯已排好序的⼦序列中，直到全部记录插⼊完成。
### 2. 算法过程
![[img/09 排序/03 插入排序1.png]]
![[img/09 排序/04 插入排序2.png]]
![[img/09 排序/05 插入排序3.png]]
![[img/09 排序/06 插入排序4.png]]
![[img/09 排序/07 插入排序5.png]]
### 3. 算法实现
插入排序能够很明显地体现了递归思想，即每次插入其实都是在调用自己。
```c
// 直接插入排序
void InsertSort(int A[]; int n){
    int i, j, temp;
    for (i = 1; i < n; i++){    // 外层循环,逐个遍历
        if (A[i] < A[i-1]){     // A[i] 小于前驱
            temp = A[i];        // A[i] 缓存进temp内
            /*
            在前i-1个数中，从后往前追溯，一旦遇到不大于temp的立即停止
            表现为 出现比temp大的一直继续
            */
            for(j = i - 1; j >= 0 && A[j] > temp; --j){
                // 给temp 挪位置，原来的A[i] 被A[i-1]替换了，已经物是人非了
                A[j + 1] = A[j];    
            }
            // 把temp插到了它该存在的位置。
            A[j + 1] = temp;
        }
    }
}
```
如果使用带哨兵（sentinel）的方式，此时数组下标与位序一致
```c
// 直接插入排序
void InsertSort(int A[]; int n){
    int i, j;
    // 外层循环,逐个遍历
    for(i = 2; i <= n; i++){    
        if(A[i] < A[i-1]){
            // 用哨兵存储将要排序的大数
            A[0] = A[i];
            // 从后往前依次对比，直至遇到 A[0] >= A[j]
            for(j = i - 1; A[0] < A[j]; --j){
            // 逐步后移    
                A[j + 1] = A[j];
            }
            // 在A[j] 后插入大数
            A[j + 1] = A[0];
        }    
    }
}
```
使用带哨兵的插入排序，优点即不用每轮都判断 `j>=0`，运行效率略高一点。
空间复杂度：$O(1)$
时间复杂度：$O(N^2)$   最好时间复杂度$O(N)$，最坏时间复杂度$O(N^2)$
    主要对比关键字、移动元素。若有n个元素，则需要(n-1)趟。
算法稳定性：稳定排序

### 4. 算法优化
在插入时，将原来的遍历插入改变成折半插入。即在找寻插入位置的时候，采用折半查找。
思路：先⽤折半查找找到应该插⼊的位置，再移动元素。
![[img/09 排序/08 折半插入 1.png]]
![[img/09 排序/09 折半插入 2.png]]
当 low>high 时折半查找停⽌，应将 `[low, i-1]`内的元素全部右移，并将 `A[0]` 复制到 `low` 所指位置。
```c
// 折半插入查找，采用哨兵方式
void InsertSort(int A[],int n){
    int i, j, high, mid;
    // 外层循环,逐个遍历
    for (i = 2; i <= n; i++){
        A[0] = A[i];
        // 设置折半查找的范围
        low = 1; high = i - 1;
        // 折半查找范围限制
        while (low <= high){
            // 取半点
            mid = (low + high) / 2;
            // 查找左半 子表
            if (A[mid] > A[0]){
                high = mid -1;
            } 
            // 查找又半子表
            else{
                low = mid + 1;
            }
        }
        // 统一后移，空出插入位置
        for (j = i - 1; j > high + 1; --j){
            A[j + 1] = A[j];
        }
        // 在A[high]后插入完成
        A[high + 1] = A[0];
    }
}
```
⽐起“直接插⼊排序”，⽐较关键字的次数减少了，但是移动元素的次数没变，整体来看时间复杂度依然是$O(N^2)$。
对**链表**进⾏插⼊排序：只能通过直接插入。
移动元素的次数变少了，但是关键字对⽐的次数依然是$O(N^2)$ 数量级，整体来看时间复杂度依然是$O(N^2)$。

# [78] 希尔排序（Shell Sort）
### 1. 算法思想
希尔排序：先追求表中元素部分有序，再逐渐逼近全局有序。
![[img/09 排序/10 希尔排序 1.png]]
对于插入排序而言，如果原本的表中元素基本有序的话，那采用直接插入排序会达到一个相应不错的效率。
具体方法：先将待排序表分割成若⼲形如 $L[ i, i + d, i + 2d,…, i + kd ]$ 的“特殊”⼦表，对各个⼦表分别进⾏直接插⼊排序。缩⼩增量$d$，重复上述过程，直到$d = 1$为⽌。
### 2. 算法过程
![[img/09 排序/11 希尔排序 2.png]]
![[img/09 排序/12 希尔排序 3.png]]
![[img/09 排序/13 希尔排序 4.png]]
### 3. 算法实现
以`{'49','38','65','97','76','13','27','49'}`表排序为例。
```c
// 希尔排序
void shellSort(int A[],int n){
    // d是元素的增量，
    int d, i, j;
    // A[0]是暂存单元，不是哨兵，当j <= 0时,插入位置已到
    for(d = n/2; d >= 1; d = d/2){      // 控制步长
        for (i = d + 1; i <= n; ++i){
            if (A[i] <= A[i-d]){        // 需要将A[i]插入有序增量子表
                A[0] = A[i];            // 暂存在A[0]
                for(j= i-d;j>0&& A[0]<A[j]; j-=d){
                    A[j+d] = A[j];      // 记录后移
                }
                A[j+d] = A[0];          // 插入
            }
        }
    }
}
```
动画演示：
![[img/09 排序/14 希尔排序 代码实现1.png]]
![[img/09 排序/15 希尔排序 代码实现2.png]]
![[img/09 排序/16 希尔排序 代码实现3.png]]
![[img/09 排序/17 希尔排序 代码实现4.png]]
![[img/09 排序/18 希尔排序 代码实现5.png]]
![[img/09 排序/19 希尔排序 代码实现6.png]]
![[img/09 排序/20 希尔排序 代码实现7.png]]

![[img/09 排序/21 希尔排序 代码实现8.png]]
![[img/09 排序/22 希尔排序 代码实现9.png]]
![[img/09 排序/23 希尔排序 代码实现10.png]]
### 4. 算法性能
空间复杂度：$O(1)$
时间间复杂度：和增量序列 $d_1, d_2, d_3…$ 的选择有关，⽬前⽆法⽤数学⼿段证明确切的时间复杂度。
最坏时间复杂度为 $O(N^2)$，当$n$在某个范围内时，可达$O(n^{1.3})$
稳定性：不稳定的排序算法
适⽤性：仅适⽤于顺序表，不适⽤于链表

# [79] 冒泡排序
### 1. 算法思想
基于“交换”的排序：根据序列中两个元素关键字的⽐较结果来对换这两个记录在序列中的位置。
交换排序有“冒泡排序”和“快速排序”两种。
### 2. 算法过程
从后往前（或从前往后）两两⽐较相邻元素的值，若为逆序（即`A[i-1]>A[i]`），则交换它们，直到序列⽐较完。称这样过程为“⼀趟”冒泡排序。
第⼀趟：排序使关键字值最⼩的⼀个元素“冒”到最前⾯。
第二趟：前边已经确定最终位置的元素不⽤再对⽐。结束后，最⼩的2个元素会“冒”到最前边。
第二趟：前边已经确定最终位置的元素不⽤再对⽐。结束后，最⼩的3个元素会“冒”到最前边。
.....
若某⼀趟排序没有发⽣“交换”，说明此时已经整体有序。
以第一趟为例：
![[img/09 排序/24 冒泡排序 1.png]]
![[img/09 排序/25 冒泡排序 2.png]]
![[img/09 排序/26 冒泡排序 3.png]]
第⼀趟排序结束，**关键字值最⼩**的⼀个元素“冒”到最前⾯。
![[img/09 排序/27 冒泡排序 4.png]]
![[img/09 排序/28 冒泡排序 5.png]]
![[img/09 排序/29 冒泡排序 6.png]]
第二趟结束后，最⼩的两个元素会“冒”到最前边。
![[img/09 排序/30 冒泡排序 7.png]]
若某⼀趟排序没有发⽣“交换”，说明此时已经整体有序。
当第5趟结束的时候，整个表已经整体有序了，说明不需要再排列了。

冒泡排序中，从后往前（或从前往后）两两⽐较相邻元素的值，若为逆序（即`A[i-1]>A[i]`），则交换它们，直到序列⽐较完。称这样过程为**“⼀趟”冒泡排序**。总共需进⾏ `n-1` 趟冒泡。
### 3. 算法实现
```c
void swap(int &a, int &b){
     int temp = a;
     a = b;
     b = temp; 
}
void BubbleSort(int A[], int n){
    // i 所指位置之前的元素都已“有序”
    for(int i = 0; i < n-1; i++){
        bool flag = false;              // 本趟冒泡是否发生交换的标志
        for(int j = n-1; j > i; j--){     // 一趟冒泡过程
            if(A[j - 1] > A[j]){          // 若为逆序
                swap(A[j - 1],A[j]);      // 交换
                flag = true;
            }
        }
        if(!flag){
            return;                     // 本遍历后没有发生交换，说明表已经有序
        }
    }
}
```
### 4. 算法性能
空间复杂度：$O(1)$
最好情况（有序）：⽐较次数=$n-1$; 交换次数=0  最好时间复杂度 = $O(N)$
最坏情况（逆序）：⽐较次数=$(n-1)+(n-2)+…+1$ = $\frac{n(n-1)}{2}$ = 交换次数 最坏时间复杂度 = $O(N^2)$
平均时间复杂度：$O(N^2)$

注意：`swap(a,b)`每次交换都需要移动元素3次
冒泡排序**同样适⽤于链表**，可从前往后“冒泡”，每⼀趟将更⼤的元素“冒”到链尾。
