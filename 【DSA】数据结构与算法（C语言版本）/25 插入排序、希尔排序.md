#数据结构 #算法 #C

排序算法是《数据结构与算法》中最基本的算法之一。
排序算法可以分为内部排序和外部排序：
- 内部排序是数据记录在内存中进行排序，
- 外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。

常见的内部排序算法有：**插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序**等。  
用一张图对比各算法：

![](img/08_排序/01%20十大排序.jpg)

# [83] 排序基本概念
排序（Sort），就是重新排列表中的元素，使表中的元素满⾜按关键字有序的过程。

- 输⼊： $n$  个记录 $R_1, R_2,…, R_n$ ，对应的关键字为 $k_1, k_2,…, k_n$ 。  
- 输出：输⼊序列的⼀个重排 $R_1ʹ, R_2ʹ,…, R_nʹ$，使得有 $k_1ʹ≤k_2ʹ≤…≤k_nʹ$ （也可递减）。  

- 算法的稳定性：若待排序表中有两个元素 $R_i$ 和 $R_j$ ，其对应的关键字相同即$key_i = key_j$，且在排序前 $R_i$ 在 $R_j$ 的前⾯，若**使⽤某⼀排序算法排序后**，$R_i$仍然在$R_j$的前⾯，则称这个**排序算法是稳定的**，否则称排序算法是不稳定的。

![[img/08_排序/01 排序的稳定性.png]]

- **内部排序**：数据都在内存中，关注如何使算法时、空复杂度更低。
- **外部排序**：数据太多，无法全部放入内存。还要关注如何使读/写磁盘次数更少。

![[img/08_排序/02 内部排序 VS 外部排序.png]]

# [84] 插入排序
## 1. 算法思想
每次将⼀个待排序的记录按其关键字大小插⼊到前⾯已排好序的⼦序列中，直到全部记录插⼊完成。
## 2. 算法过程
![[img/08_排序/03 插入排序1.png]]
![[img/08_排序/04 插入排序2.png]]
![[img/08_排序/05 插入排序3.png]]
![[img/08_排序/06 插入排序4.png]]
![[img/08_排序/07 插入排序5.png]]
## 3. 算法实现
插入排序能够很明显地体现了递归思想，即每次插入其实都是在调用自己。
```c
// 直接插入排序
void InsertSort(int A[]; int n){
    int i, j, temp;
    for (i = 1; i < n; i++){    // 外层循环,逐个遍历
        if (A[i] < A[i-1]){     // A[i] 小于前驱
            temp = A[i];        // A[i] 缓存进temp内
            /*
            在前i-1个数中，从后往前追溯，一旦遇到不大于temp的立即停止
            表现为 出现比temp大的一直继续
            */
            for(j = i - 1; j >= 0 && A[j] > temp; --j){
                // 给temp 挪位置，原来的A[i] 被A[i-1]替换了，已经物是人非了
                A[j + 1] = A[j];    
            }
            // 把temp插到了它该存在的位置。
            A[j + 1] = temp;
        }
    }
}
```

如果使用带哨兵（sentinel）的方式，此时数组下标与位序一致。
```c
// 直接插入排序
void InsertSort(int A[]; int n){
    int i, j;
    // 外层循环,逐个遍历
    for(i = 2; i <= n; i++){    
        if(A[i] < A[i-1]){
            // 用哨兵存储将要排序的大数
            A[0] = A[i];
            // 从后往前依次对比，直至遇到 A[0] >= A[j]
            for(j = i - 1; A[0] < A[j]; --j){
            // 逐步后移    
                A[j + 1] = A[j];
            }
            // 在A[j] 后插入大数
            A[j + 1] = A[0];
        }    
    }
}
```
## 4. 算法性能分析
使用带哨兵的插入排序，优点即不用每轮都判断 `j >= 0`，运行效率略高一点。  
- 空间复杂度：$O(1)$  
- 时间复杂度：$O(N^2)$ 
    - 其中最好时间复杂度 $O(N)$ ，最坏时间复杂度$O(N^2)$  
    - 主要对比关键字、移动元素。若有 n 个元素，则需要 (n - 1) 趟。
- 算法稳定性：稳定排序

## 5. 算法优化
在插入时，将原来的遍历插入改变成折半插入。即在找寻插入位置的时候，采用二分查找。  
思路：先⽤二分查找找到应该插⼊的位置，再移动元素。

![[img/08_排序/08 折半插入 1.png]]
![[img/08_排序/09 折半插入 2.png]]

当 `low>high` 时折半查找停⽌，应将 `[low, i - 1]`内的元素全部右移，并将 `A[0]` 复制到 `low` 所指位置。

```c
// 折半插入查找，采用哨兵方式
void InsertSort(int A[],int n){
    int i, j, high, mid;
    // 外层循环,逐个遍历
    for (i = 2; i <= n; i++){
        A[0] = A[i];
        // 设置折半查找的范围
        low = 1; high = i - 1;
        // 折半查找范围限制
        while (low <= high){
            // 取半点
            mid = (low + high) / 2;
            // 查找左半 子表
            if (A[mid] > A[0]){
                high = mid -1;
            } 
            // 查找又半子表
            else{
                low = mid + 1;
            }
        }
        // 统一后移，空出插入位置
        for (j = i - 1; j > high + 1; --j){
            A[j + 1] = A[j];
        }
        // 在A[high]后插入完成
        A[high + 1] = A[0];
    }
}
```

采用二分查找插入，⽐起“直接插⼊排序”，⽐较关键字的次数减少了，但是移动元素的次数没变，整体来看时间复杂度依然是 $O(N^2)$ 。
对链表这类数据结构进⾏插⼊排序：只能通过直接插入，因为链表不具备随机存取特点，无法进行二分查找。

虽然移动元素的次数变少了，但是关键字对⽐的次数依然是 $O(N^2)$ 数量级，整体来看时间复杂度依然是 $O(N^2)$ 。

# [85] 希尔排序（Shell Sort）
## 1. 算法思想
希尔排序：先追求表中元素部分有序，再逐渐逼近全局有序。

![[img/08_排序/10 希尔排序 1.png]]

对于插入排序而言，如果原本的表中元素基本有序的话，那采用直接插入排序会达到一个相应不错的效率。  

具体方法：先将待排序表分割成若干形如 $L[ i, i + d, i + 2d,…, i + kd ]$ 的“特殊”⼦表，对各个⼦表分别进⾏直接插⼊排序。缩⼩增量 $d$，重复上述过程，直到 $d = 1$ 为⽌。

## 2. 算法过程

![[img/08_排序/11 希尔排序 2.png]]
![[img/08_排序/12 希尔排序 3.png]]
![[img/08_排序/13 希尔排序 4.png]]

## 3. 算法实现
以`{'49','38','65','97','76','13','27','49'}`表排序为例。
```c
// 希尔排序
void shellSort(int A[],int n){
    // d是元素的增量，
    int d, i, j;
    // A[0]是暂存单元，不是哨兵，当j <= 0时,插入位置已到
    for(d = n/2; d >= 1; d = d/2){      // 控制步长
        for (i = d + 1; i <= n; ++i){
            if (A[i] <= A[i-d]){        // 需要将A[i]插入有序增量子表
                A[0] = A[i];            // 暂存在A[0]
                for(j= i-d;j>0&& A[0]<A[j]; j-=d){
                    A[j+d] = A[j];      // 记录后移
                }
                A[j+d] = A[0];          // 插入
            }
        }
    }
}
```

动画演示：
![[img/08_排序/14 希尔排序 代码实现1.png]]
![[img/08_排序/15 希尔排序 代码实现2.png]]
![[img/08_排序/16 希尔排序 代码实现3.png]]
![[img/08_排序/17 希尔排序 代码实现4.png]]
![[img/08_排序/18 希尔排序 代码实现5.png]]
![[img/08_排序/19 希尔排序 代码实现6.png]]
![[img/08_排序/20 希尔排序 代码实现7.png]]

![[img/08_排序/21 希尔排序 代码实现8.png]]
![[img/08_排序/22 希尔排序 代码实现9.png]]
![[img/08_排序/23 希尔排序 代码实现10.png]]

## 4. 算法性能分析
- 空间复杂度： $O(1)$
- 时间间复杂度：和增量序列 $d_1, d_2, d_3…$ 的选择有关，⽬前⽆法⽤数学⼿段证明确切的时间复杂度。
  - 最坏时间复杂度为 $O(N^2)$ ，当 $n$ 在某个范围内时，可达 $O(N^{1.3})$
- 稳定性：不稳定的排序算法
- 适⽤性：仅适⽤于顺序表，不适⽤于链表。

