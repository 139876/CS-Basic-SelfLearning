#数据结构 #C 
# [49] 在线索二叉树中找前驱后继
二叉树的线索化，最终目的时为了找到遍历序列的前驱和后继。在完成二叉树线索化的前提下，以下讲着重探讨在不同类型的线索二叉树下，怎么找前驱和后继。

## 1.中序线索二叉树找中序后继
【问题】  
中序线索二叉树，如何找到指定结点 `*p` 的中序后继 `next`？

【解答】
1. 若 `p->rtag == 1`，则`next = p->rchild`;
    - 因为中序遍历：左-->根--> 右，
    - 如果`rtag`值表示1，即表示该叶子结点有后继线索，直接赋值即可;
2. 若 `p->rtag == 0`，表示这个结点一定是有右孩子的，那么后继`next` 指向 `p`的右子树中最左下的结点。

![](img/06_树2/11%20中序遍历线索二叉树,左右孩子存在,求其后继.jpg)

#未完待续
代码实现：
```c
typedef struct ThreadNode {
    ElemType data;
    ThreadNode *lchild, *rchild;
    int ltag, rtag;        // 左、右线索标志
} ThreadNode, *ThreadTree;

// 函数调用：InOrder --> NextNode --> FirstNode
// 对中序线索二叉树进行中序遍历(利用线索实现的非递归算法)
void InOrder(ThreadNode *T)
{
    for(ThreadNode *p = FirstNode(T); p != NULL; 
        p = NextNode(p)){
        visit(p);
    }
}

// 中序线索二叉树中找到结点p的后继结点
ThreadNode *NextNode(ThreadNode *p)
{
    // 右子树中最左下结点
    if (p->rtag == 0){
        return FirstNode(p->rchild);
    } else {
        // rtag == 1 直接返回后继线索。
        return p->rchild;
    }
}

// 找到以P为根的子树，第一个被中序遍历的结点
ThreadNode *FirstNode(ThreadNode *p)
{
    // 循环找到最左下结点(不一定是叶结点)
    while (p->ltag == 0){
        p = p->lchild;
    }
    return p;
}
```

## 2.中序线索二叉树找中序前驱
【问题】
中序线索二叉树，如何找到指定结点 `*p` 的中序前驱 `pre`？

【解答】
1. 若 `p->ltag == 1`，则`pre = p->lchild`;
    - 中序遍历：左-->根--> 右，
    - 如果`ltag`值表示1，即表示该叶子结点有前驱线索，直接赋值即可;
2. 若 `p->ltag == 0`，表示这个结点一定是有左孩子的，前驱`pre` 指向 `p` 的左子树中最右下的结点。

![](img/06_树2/12%20中序遍历线索二叉树,左右孩子存在,求其前驱.jpg)

代码实现：
```c
// 对中序线索二叉树进行逆向中序遍历(利用线索实现的非递归算法)
void ReverseInOrder(ThreadNode *T)
{
    for(ThreadNode *p = LastNode(T); p != NULL; 
        p = PreNode(p)){
        visit(p);
    }
}

// 中序线索二叉树中找到结点p的前驱结点
ThreadNode *PreNode(ThreadNode *p)
{
    // 左子树中最右下结点
    if (p->rtag == 0){
        return LastNode(p->lchild);
    } else {
        // ltag == 1 直接返回后继线索。
        return p->lchild;
    }
}

// 找到以P为根的子树，最后一个被中序遍历的结点
ThreadNode *LastNode(ThreadNode *p)
{
    // 循环找到最右下结点(不一定是叶结点)
    while (p->rtag == 0){
        p = p->rchild;
    }
    return p;
}
```

## 3.先序线索二叉树找先序后继
【问题】
先序线索二叉树（根节点--> 左孩子 --> 右孩子），如何找到指定结点 `*p` 的先序后继 `next`？

【解答】
1. 若 `p->rtag == 1`，同理，则`next = p->rchild`;
2. 若 `p->rtag == 0`，表示这个结点一定是有右孩子的，这个时候，需要对这个结点的左孩子情况进行讨论。
   - 如果有左孩子，那么先序后继为左孩子；
   - 如果有没有左孩子，那么先序后继为右孩子。

![](img/06_树2/13%20先序遍历线索二叉树,左右孩子存在,求其后继.jpg)
算法实现：
```c
// 找先序线索二叉树p的后继
ThreadNode *FindPreOrderNext(ThreadNode *p){
    if (p->rtag == 1){
        return p->rchild;
    } else if (p->ltag == 0){
        return p->lchild;
    } else {
        return p->rchild;
    }
}
```

## 4.先序线索二叉树找先序前驱
【问题】
先序线索二叉树（根节点--> 左孩子 --> 右孩子），如何找到指定结点 `*p` 的先序前驱 `pre`？

【解答】
在先序遍历中，某一个结点的左右子树只可能是它的后继，均不可能是它的前驱，所以，如果要求其前驱，有两种方法：
1. 可以使用最原始的方式从根节点依次遍历，但是浪费时间，时间复杂度 $O(N)$ 。   
2. 采取三叉链表的数据结构，分配一个指针，用于指向该结点的父结点。  
```c
typedef struct BiTNode {
    ElemType data;                
    struct BiTNode *lchild, *rchild;    // 左、右孩子指针
    struct BiTNode *parent;             // 父节点指针
} BiTNode, *BiTree;                     // 三叉链表，方便找父节点
```
如果采取后者，就需要对具体情况进行分类**逐个讨论**了：

![](img/06_树2/14%20先序遍历线索二叉树,左右孩子存在,求其前驱.jpg)

- 情形1:   
如果能找到`p`的父节点，且`p`是左孩子。父结点是前驱。
```c
if (p->parent != NULL && p = p->parent->lchild) {
    pre = p->parent;
}
```
- 情形2：  
如果能找到`p`的父节点，且`p`是右孩子，其左兄弟为空。父结点是前驱。
```c
if (p->parent != NULL && p = p->parent->rchild && p->parent->lchild == NULL) {
    pre = p->parent;
}
```
- 情形3：  
如果能找到`p`的父节点，且`p`是右孩子且左孩子不为空。**左兄弟子树最后一个被先序遍历的结点**是前驱。
```c
BiTNode* pre == NULL;
// visit 操作函数写入pre
void visit(BiNode *T)
{
    pre = T;
    return;
}

if (p->parent != NULL && p = p->parent->rchild && p->parent->lchild != NULL) {
    // 先序遍历，并将变量存储在pre中
    PreOrder(p->parent->lchild);
    return pre;
}
```
- 情形4：  
没有父节点。没有前驱。
```c
if (p->parent == NULL) {
    pre = NULL;
}
```

## 5.后序线索二叉树找后序前驱
【问题】  
后序线索二叉树（左孩子 --> 右孩子-->根节点 ），如何找到指定结点 `*p` 的后序前驱 `pre`？

【解答】
1. 若 `p->ltag == 1`，则`pre = p->lchild`（同理）;
2. 若 `p->ltag == 0`，表示这个结点一定是有左孩子的。这个时候，需要对这个结点的左孩子情况进行讨论。
   - 如果有右孩子，那么后序前驱为右孩子；
   - 如果没有右孩子，那么后序前驱为左孩子；

![](img/06_树2/15%20后序遍历线索二叉树,左右孩子存在,求其前驱.jpg)

```c
// 找后序线索二叉树p的前驱
ThreadNode *FindPostOrderPre(ThreadNode *p){
    if (p->rtag == 1){
        return p->lchild;
    } else if (p->rtag == 0){
        return p->rchild;
    } else {
        return p->lchild;
    }
}
```

## 6.后序线索二叉树找后序后继
【问题】  
后序线索二叉树（左孩子 --> 右孩子-->根节点 ），如何找到指定结点 `*p` 的后序后继 `pre`？

【解答】  
后序遍历中，某一个结点的左右子树只可能是它的前驱，均不可能是它的后继，所以，如果要求其后继，有两种方法：
1. 使用最原始的方式从根节点依次遍历，时间复杂度 $O(N)$。
2. 或者采取三叉链表的数据结构，分配一个指针，用于指向该结点的父结点。
```c
typedef struct BiTNode {
    ElemType data;                
    struct BiTNode *lchild, *rchild;    // 左、右孩子指针
    struct BiTNode *parent;             // 父节点指针
} BiTNode, *BiTree;                     // 三叉链表，方便找父节点
```
如果采取后者，同样需要对具体情况进行分类**逐个讨论**了：

![](img/06_树2/16%20后序遍历线索二叉树,左右孩子存在,求其后继.jpg)

- 情形1：  
  如果能找到p的父节点，且p是右孩子。父结点是后继。
```c
if (p->parent != NULL && p = p->parent->rchild) {
    next = p->parent;
}
```
- 情形2：  
  如果能找到p的父节点，且p是左孩子，其右兄弟为空。父结点是后继。
```c
if (p->parent != NULL && p = p->parent->lchild && p->parent->rchild == NULL) {
    next = p->parent;
}
```
- 情形3：  
  如果能找到p的父节点，且p是左孩子且右孩子不为空。**右兄弟子树第一个被后序遍历的结点**是后继。
```c
BiTNode* next == NULL;
// visit 操作函数条件判定, next == NULL，写入NULL，否则不要写入
void visit(BiNode *T)
{
    if (next == NULL) {
        next = T;
    } 
    return;
}

if (p->parent != NULL && p = p->parent->lchild && p->parent->rchild != NULL) {
    // 后序遍历，并将变量存储在next中
    PostOrder(p->parent->rchild);
    return next;
}
```
- 情形4：  
  没有父节点。没有后继。
```c
if (p->parent == NULL) {
    next = NULL;
}
```
