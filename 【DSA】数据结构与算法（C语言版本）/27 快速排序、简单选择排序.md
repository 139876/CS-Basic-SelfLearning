#数据结构 #算法 #C
# [86] 快速排序
“快速排序”是交换排序的另一种。
### 1. 算法思想
在待排序表 $L[1…n]$ 中任取⼀个元素pivot作为枢轴（或基准，通常取⾸元素），通过⼀趟排序将待排序表划分为独⽴的两部分$L[1…k-1]$和$L[k+1…n]$，使得$L[1…k-1]$中的所有元素⼩于pivot，$L[k+1…n]$中的所有元素⼤于等于pivot，则pivot放在了其最终位置$L(k)$上，这个过程称为⼀次“划分”。然后分别递归地对两个⼦表重复上述过程，直⾄
每部分内只有⼀个元素或空为⽌，即所有元素放在了其最终位置上。
### 2. 算法过程
以数组A`{49,38,65,97,76,13,27,49}`为例，以递归工作栈的方式来实现快速排序。
把最起初的数字`A[0]`的值49作为中枢，即基准。

![[img/08_排序/png/31 快速排序 第一层1.png]]
![[img/08_排序/png/32 快速排序 第一层2.png]]
![[img/08_排序/png/33 快速排序 第一层3.png]]

以pivot为中枢，对其他元素按照大小值，小于pivot的放于左侧，大于pivot的放于右侧。然后将pivot填入其中。
进入下一层递归：
![[img/08_排序/png/34 快速排序 第二层 1.png]]

![[img/08_排序/png/35 快速排序 第二层 2.png]]
![[img/08_排序/png/36 快速排序 第三层 1.png]]
![[img/08_排序/png/37 快速排序 第三层 2.png]]
![[img/08_排序/png/38 快速排序 第三层 3.png]]
![[img/08_排序/png/39 快速排序第三层 5.png]]


![[img/08_排序/png/40 快速排序回溯 空栈.png]]


### 3. 算法实现
```c
// 用第一个元素将待排序序列划分分为左右两个部分
int Partition(int A[], int low, int high){
    // 把第一个元素当作枢轴
    int pivot = A[low];             
    // 用low、high搜索枢轴的最终位置，
    // 当low与high相碰的时候和或者 low溢出high的时候 结束
    while (low < high){
        // 比枢轴小的元素移动到左端
        while (low < high && A[high] >= pivot){
            --high;
        }
        A [low] = A [high];
        // 比枢轴大的元素移动到右端
        while (low < high && A[low] <= pivot){
            ++low;
        }
        A[high] = A[low];
    }
    // 返回存放枢轴的最终位置
    A[low] = pivot;             
}

// 快速排序
void QuickSort(int A[], int low, int high){
    if (low < high){                            // 递归跳出条件
        int pivotpos = Partition(A,low,high);   // 划分
        QuickSort(A, low, pivotops - 1);        // 划分左子表
        QuickSort(A, low, pivotops - 1);        // 划分右子表
    }
}
```
每⼀层的`QuickSort` 只需要处理剩余的待排序元素，时间复杂度不超过$O(N)$

### 4. 算法性能
把n个元素组织成⼆叉树，⼆叉树的层数就是递归调⽤的层数
n个结点的⼆叉树最⼩⾼度 = $⌊log2n⌋ + 1$，最⼤⾼度 = $n$
![[img/08_排序/png/42 快速排序  二叉树转化.png]]
- **特殊情形下的快速排序**：
    若每⼀次选中的“枢轴”将待排序序列划分为很不均匀的两个部分，则会导致递归深度增加，算法效率变低。
    若初始序列有序或逆序，则快速排序的性能最差（因为每次选择的都是最靠边的元素）。
- ** 快速排序的优化**：
    尽量选择可以把数据中分的枢轴元素。
    eg：①选头、中、尾三个位置的元素，取中间值作为枢轴元素；②随机选⼀个元素作为枢轴元素。
- **综合对比**：
    快速排序是所有内部排序算法中**平均性能最优**的排序算法。
    时间复杂度=$O(n*递归层数)$，
        最好时间复杂度=$O(n\log_{2}{n})$，最坏时间复杂度=$O(N^2)$，平均时间复杂度=$O(n\log_{2}{n})$
    空间复杂度=$O(递归层数)$，
        最好空间复杂度=$O(\log_{2}{n})$，最坏时间复杂度=$O(N)$。
    快速排序是不稳定的排序。


# [87] 简单选择排序
选择排序：每⼀趟在待排序元素中选取关键字最⼩（或最⼤）的元素加⼊有序⼦序列。
其中，选择排序又分为——**简单选择排序**和**堆排序**。
### 1. 算法思想
每⼀趟在待排序元素中选取关键字最⼩的元素加⼊有序⼦序列
### 2. 算法过程
以数组A`{49,38,65,97,76,13,27,49}`为例，对n个元素的简单选择排序需要 n-1 趟处理。
![[img/08_排序/png/43 简单选择排序.png]]
![[img/08_排序/png/44 简单选择排序.png]]
![[img/08_排序/png/45 简单选择排序.png]]
![[img/08_排序/png/46 简单选择排序.png]]
### 3. 算法实现
```c
void swap(int &a, int &b){
     int temp = a;
     a = b;
     b = temp; 
}

void SelectSort(int A[],int n){
    // 一共进行 n-1 趟, i指代待排序的元素开头位置
    for (int i =0; i < n - 1; i++){
        // 记录最小元素位置
        int min = i;
        // 在 A[i, n-1]中找最小的元素
        for (int j = i + 1; j < n; j++){
            // 更新最小的元素
            if (A[j] < A[min]){
                min = j;
            }
        }

        if (min != i){
            swap(A[i], A[min]);
        }
    }
}
```
### 4. 算法性能
⽆论有序、逆序、还是乱序，⼀定需要 n-1 趟处理
总共需要对⽐关键字$(n-1) + (n-2)+ … + 1 = \frac{n(n-1)}{2}$次，元素交换次数 < $n-1$
时间复杂度 = $O(N^2)$
空间复杂度 = $O(1)$

