#数据结构 #C 
# [53] 哈夫曼树
## 0. 基本概念
【结点的权】  
有某种现实含义的数值（如：表示结点的重要性等）。  
【结点的带权路径长度】  
从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积。  
【树的带权路径长度】  
树中所有叶结点的带权路径长度之和（WPL, Weighted Path Length）。
$$WPL = \sum_{i=1}^n W_i l_i$$

在含有n个带权叶结点的二叉树中，其中**带权路径长度（WPL）最小的二叉树称为哈夫曼树**，也称**最优二叉树**。如图，最最右侧两个二叉树中，均属于哈夫曼树（Huffman Tree）。

![](img/06_树2/20%20哈夫曼树.jpg)

## 1. 哈夫曼树构造
给定`n`个权值分别为 $w_1, w_2,…, w_n$ 的结点，构造哈夫曼树的算法描述如下：
1. 将这`n`个结点分别作为`n`棵仅含一个结点的二叉树，构成森林`F`。
2. 构造一个新结点，从`F`中选取**两棵根结点权值最小**的树作为新结点的左、右子树，并且将新
结点的权值置为左、右子树上根结点的权值之和。
3. 从`F`中删除刚才选出的两棵树，同时将新得到的树加入`F`中。
4. 重复步骤（2）和（3），直至`F`中只剩下一棵树为止。

![](img/06_树2/21%20哈夫曼树生成.jpg)
![](img/06_树2/22%20哈夫曼树生成2.jpg)

特点：
1. 每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。
2. 哈夫曼树的结点总数为`2n − 1`。
3. 哈夫曼树中不存在度为1的结点。
4. 哈夫曼树并不唯一，但 $WPL$ 必然相同且为最优。

以`{3,2,1,7,2}`为例，有两种哈夫曼树的生成方式，且带权路径长度之和均为最小。

## 2. 哈夫曼编码
【可变长度编码】
允许对不同字符用不等长的二进制位表示。
若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。
假设，100题中有80题选C，10题选A，8题选B，2题选D，如果用0，1 编码这些信息，如果使用平均使用，所有答案的二进制长度=$80*2+10*2+8*2+2*2=200$ bit。
![[img/06_树2/72 哈夫曼编码.png]]
使用哈夫曼编码，即右侧的，将使用信息：$WPL= 80*1+10*2+2*3+8*3=130$bit。
有哈夫曼树得到哈夫曼编码——字符集中的每个字符作为一个叶子结点，各个字符出现的频度作为结点的权值，根据之前介绍的方法构造哈夫曼树。
哈夫曼编码使用的方式，降低二进制编码的数量，因此哈夫曼编码可用于数据压缩。


# [54] 并查集

Disjoint-set data structure