#数据结构 
# [48]     树的存储结构
## 1. 双亲表示法
每个结点中保存指向双亲的“指针”。

![](img/05_树1/02%20子树.jpg)
```c
# define MAX_TREE_SIZE 100      // 树中最多的结点
typedef struct {        // 树的结点定义
    ElemType data;      // 数据元素
    int parent;         // 双亲位置域
} PTNode;

typedef struct {                // 树的类型定义
    PTNode node[MAX_TREE_SIZE]; // 双亲表示
    int n;                      // 结点树
} PTree;
```

| 数组下标 | data  | parent |
|:--------:|:----:|:------:|
|    0     |  A   |   -1   |
|    1     |  B   |   0    |
|    2     |  C   |   0    |
|    3     |  D   |   0    |
|    4     |  E   |   1    |
|    5     |  F   |   1    |
|    6     |  G   |   2    |
|    7     |  H   |   3    |
|    8     |  I   |   3    |
|    9     |  J   |   3    |
|    10    |  K   |   4    |
|    11    | ...  |  ...   |

其中，根节点固定存储在0，-1表示没有双亲。

问题来了，**如何让用双亲表示法实现增删查操作**？
新增数据元素时候，无需按逻辑上的次序存储，直接再尾部新增即可。例如新增M、L结点，只需要在尾部新增即可。

|  数组下标  |  data  |  parent  |
|:----------:|:------:|:--------:|
| .......... | ...... | ........ |
|     11     |   M    |    7     |
|     12     |   L    |    4     |

删除数据元素，如果是叶子结点的话，可以直接删除元素，也可以只让data值删除。
如果不是叶子结点，删除的时候，就需要找到它的所有孩子结点并且全部删除。但是，查找指定结点的孩子只能从头遍历。

## 2. 孩子表示法
采用顺序+链式存储，顺序存储各个节点，每个结点中保存孩子链表头指针。
```c
struct CTNode {
    int child;              // 孩子结点在数组中的位置
    struct CTNode *next;    // 下一个孩子
};

typedef struct {
    ElemType data;
    struct CTNode *firstChild;  // 第一个孩子
} CTBox;

typedef struct {
    CTBox nodes[MAX_TREE_SIZE];
    int n, r;               // 结点数和根的位置
}
```

![[img/06_树2/52 孩子表示法存储树.png]]

## 3. 孩子兄弟表示法
纯粹使用链表的方式存储：
```c
// 树的存储 -- 孩子兄弟表示法
typeddef struct CSNode {
    ElemType data;                           // 数据域
    struct CSNode *firstchild, *nextSibling; // 第一个孩子和右兄弟指针
} CSNode, *CSTree;
```

这样的表示方法和二叉树形式同构，可以看作是左指针和右指针表示法。
![[img/06_树2/53 树转化成二叉树.png]]
如图，树转化的二叉树中，某个结点的左右两叉完全属于不同层次。
左叉（蓝色线）为孩子，右叉（黄色线）为兄弟，沿着黄色线一直追溯即可把所有的同层次的结点全找到。相对应的，二叉树也可以复原成原来树的逻辑结构。

## 4. 森林与二叉树转化
把森林中所有的根节点全都视为兄弟。
![[img/06_树2/54 森林转化成二叉树.png]]
相对应的，二叉树也可以复原成原来森林的逻辑结构。

# [49]     树和森林的遍历
## 1. 树的遍历
树的遍历有以下几种方式：先根遍历、后根遍历、层次遍历。
1. **先根遍历**。
若树非空，先访问根结点，再依次对每棵子树进行先根遍历。
```c
// 树的先根遍历
void PreOrder (TreeNode *R)
{
    if (R != NULL) {
        visit(R);       // 访问根节点
        while( R 还有下一个子树T ){
            PreOrder(T); // 先根遍历下一个子树
        }
    }
}
```
树的**先根遍历序列**与这棵树转化形成的相应二叉树的**先序序列**相同。
如下这个树的先根遍历序列是：`ABEKFCGDHIJ`。

![[img/06_树2/53 树转化成二叉树.png]]

2. **后根遍历**。
若树非空，先依次访问每棵子树进行后根遍历，再访问根结点。
```c
// 树的先根遍历
void PostOrder (TreeNode *R)
{
    if (R != NULL) {
        while( R 还有下一个子树T ){
            PostOrder(T); // 后根遍历下一个子树
        }
        visit(R);         // 访问根节点
    }
}
```
树的**后根遍历序列**与这棵树转化形成的相应二叉树的**中序序列**相同。
如下这个数的先根遍历序列是：`KEFBCGDHIJA`。

3. **层次遍历**。
使用队列实现：
（1） 若树非空，则根结点入队；
（2） 若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队；
（3） 重复（2）直到队列为空。

> 对树的层次遍历可以称作是对树的**广度优先遍历**(Breadth_First_Search)，对数的先根遍历、后跟遍历是对树的**深度优先遍历**(Depth_First_Search)。

## 2. 森林的遍历
1. 先序遍历森林：
若森林为非空，则按如下规则进行遍历：
（1）访问森林中第一棵树的根结点。
（2）先序遍历第一棵树中根结点的子树森林。
（3）先序遍历除去第一棵树之后剩余的树构成的森林。
![[img/06_树2/54 森林转化成二叉树.png]]
对森林的先序遍历，效果等同于依次对各个树进行先根遍历，实质上，等同于依次对**二叉树的先序遍历**。
上图中森林的先序遍历是`BEKFCGDHMIJ`。

2. 中序遍历森林：
若森林为非空，则按如下规则进行遍历：
（1）中序遍历森林中第一棵树的根结点的子树森林。
（2）访问第一棵树的根结点。
（3）中序遍历除去第一棵树之后剩余的树构成的森林。

对森林的先序遍历，效果等同于依次对各个树进行后根遍历，实质上，等同于依次对**二叉树的中序遍历**。上图中森林的中序遍历是`KEFBGCMHIJD`。

| 树  | 森林 | 二叉树 |
| --- | ---- | ------ |
| 先根遍历   | 先序遍历  |  先序遍历   |
| 后根遍历   | 中序遍历  |  中序遍历   |

# [50]     二叉排序树
二叉排序树，又称二叉查找树、二叉搜索树（BST，Binary Search Tree），符合这样的特点：一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：
1. 左子树上所有结点的关键字均小于根结点的关键字；
2. 右子树上所有结点的关键字均大于根结点的关键字。
3. 左子树和右子树又各是一棵二叉排序树。
![[img/06_树2/55 BST.png]]
对二叉排序树，进行中序排列，可以得到一个递增的有序序列。
## 1. BST 的查找 
查找思路分析：
1. 若树非空，目标值与根结点的值比较；
2. 若相等，则查找成功；
3. 若小于根结点，则在左子树上查找，否则在右子树上查找，重复该步骤。
4. 查找成功，返回结点指针；查找失败返回NULL。

```c
// BST结点定义
typedef struct BSTNode {
    int key;
    struct BSTNode *lchild, *rchild;
} BSTNode, *BSTree;

// 在BST中查找值为key的结点
BSTNode *BSTSearch(BSTree T, int key)
{   
    // 树若是空的或者等于根节点的值，就可以直接结束循环
    while (T != NULL && key != T->key) {
        // key小于根结点的值，查找其左子树
        if (key < T->key) {
            // T 往下深一层，执行下一次循环
            T = T-> lchild;
        // key大于根结点的值，查找其右子树
        } else {
            // T 往下深一层，执行下一次循环
            T = T->rchild; 
        }
    }
    return T;
}
```
以上程序属于非递归（循环）的实现，如果使用递归同样可以实现：
```c
// 递归实现二叉排序树查找
BSTNode *BSTSearch(BSTree T, int key)
{
    if (T == NULL) {
        return NULL;                        // 查找失败
    }
    if (key == T->key) {
        return T;                           // 查找成功
    }
    else if (key < T->key){
        return BSTSearch(T->lchild, key);   // 在左子树中找
    }
    else if (key > T->key){
        return BSTSearch(T->rchild, key);   // 在右子树中找
    }
}
```
综合比较，循环实现的最坏空间复杂度是$O(1)$，递归实现的最坏空间复杂度是$O(h)$。

## 2. BST 的结点插入
若原二叉排序树为空，则直接插入结点；否则，若关键字k小于根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树。
```c
// 在二叉排序树插入关键字为k的新结点(递归实现)
int BSTInsert(BSTree &T, int k)
{
    // 原树为空，插入新结点
    if (T == NULL) {
        T = (BSTree)malloc(sizeof(BSTNode));
        T->key = k;
        T->lchild = T->rchild = NULL;
        return 1;
    }
    // 已经存在相同关键字的结点，插入失败
    else if (K == T->key) {
        return 0;
    } 
    // 插入到T的左子树
    else if (K < T->key) {
        return BSTInsert(T->lchild, k);
    } 
    // 插入到T的右子树
    else {
        return BSTInsert(T->rchild, k);
    }
}
```
对于二叉排序树的插入而言，新插入的结点一定是叶子，并且使用递归，最坏空间复杂度为$O(h)$。

## 3. BST 的构造
【例题】依照序列array[n]建立BST。
```c
// 按照array[]中关键词序列依次建立二叉排序树
void CreateBST(BSTree &T, int array[], int n)
{
    T = NULL;           // 二叉树初始化为空树
    int i = 0;
    while (i < n)
    {
        // 依次调用BST插入函数，插入数组每个元素
        BSTInsert(T, str[i]);
        i++;
    }
}
```

## 4. BST 的数据删除 
先搜索找到目标结点：
1. 若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。
2. 若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。
3. 若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。
- z的后继：z的右子树中最左下结点（该节点一定没有左子树）。
- z的前驱：z的左子树中最右下结点（该节点一定没有右子树）。

## 5. BST 的效率分析 
查找长度——在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度。
查找成功的平均查找长度 ASL（Average Search Length）：若树高h，找到最下层的一个结点需要对比 h 次。

![[img/06_树2/56 BST查找成功ASL.png]]

- **最好情况**：n个结点的二叉树最小高度为$⌊log_2{n}⌋+ 1$。平均查找长度= $O(log_2{n})$。
- **最好情况**：每一个结点只有一个分支，树高度为h，结点树 n = h，平均查找长度= $O(n)$。

![[img/06_树2/57 BST查找失败ASL.png]]
查找失败的的平均查找长度（ASL）也可以进行计算。

