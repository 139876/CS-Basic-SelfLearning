#数据结构 #算法  #C 
# [55] 二叉排序树
二叉排序树，又称二叉查找树、二叉搜索树（BST，Binary Search Tree），符合这样的特点：一棵是空二叉树，或者是具有如下性质的二叉树：
1. 左子树上所有结点的关键字均小于根结点的关键字；
2. 右子树上所有结点的关键字均大于根结点的关键字。
3. 左子树和右子树又各是一棵二叉排序树。

![](img/06_树2/33%20二叉排序树BST.jpg)

对二叉排序树，进行中序排列，可以得到一个递增的有序序列。
## 1. BST 的查找 
查找思路分析：
1. 若树非空，目标值与根结点的值比较；
2. 若相等，则查找成功；
3. 若小于根结点，则在左子树上查找，否则在右子树上查找，重复该步骤。
4. 查找成功，返回结点指针；查找失败返回NULL。

```c
// BST结点定义
typedef struct BSTNode {
    int key;
    struct BSTNode *lchild, *rchild;
} BSTNode, *BSTree;

// 在BST中查找值为key的结点
BSTNode *BSTSearch(BSTree T, int key)
{   
    // 树若是空的或者等于根节点的值，就可以直接结束循环
    while (T != NULL && key != T->key) {
        // key小于根结点的值，查找其左子树
        if (key < T->key) {
            // T 往下深一层，执行下一次循环
            T = T-> lchild;
        // key大于根结点的值，查找其右子树
        } else {
            // T 往下深一层，执行下一次循环
            T = T->rchild; 
        }
    }
    return T;
}
```
以上程序属于非递归（循环）的实现，如果使用递归同样可以实现：
```c
// 递归实现二叉排序树查找
BSTNode *BSTSearch(BSTree T, int key)
{
    if (T == NULL) {
        return NULL;                        // 查找失败
    }
    if (key == T->key) {
        return T;                           // 查找成功
    }
    else if (key < T->key){
        return BSTSearch(T->lchild, key);   // 在左子树中找
    }
    else if (key > T->key){
        return BSTSearch(T->rchild, key);   // 在右子树中找
    }
}
```
综合比较，循环实现的最坏空间复杂度是 $O(1)$，递归实现的最坏空间复杂度是 $O(h)$。综合判断，循环实现效果更好。

## 2. BST 的结点插入
算法实现：
- 若原二叉排序树为空，则直接插入结点；
- 否则，若关键字k小于根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树。  

这里的的实现依赖递归：
```c
// 在二叉排序树插入关键字为k的新结点(递归实现)
int BSTInsert(BSTree &T, int k)
{
    // 原树为空，插入新结点
    if (T == NULL) {
        T = (BSTree)malloc(sizeof(BSTNode));
        T->key = k;
        T->lchild = T->rchild = NULL;
        return true;
    }
    // 已经存在相同关键字的结点，插入失败
    else if (K == T->key) {
        return false;
    } 
    // 插入到T的左子树
    else if (K < T->key) {
        return BSTInsert(T->lchild, k);
    } 
    // 插入到T的右子树
    else {
        return BSTInsert(T->rchild, k);
    }
}
```
对于二叉排序树的插入而言，新插入的结点一定是叶子，并且使用递归，最坏空间复杂度为$O(h)$。

## 3. BST 的构造
【问题】  
如何依照序列`array[n]`建立BST？  
【实现】  
按照序列，依次插入二叉排序树中。  
```c
// 按照array[]中关键词序列依次建立二叉排序树
void CreateBST(BSTree &T, int array[], int n)
{
    T = NULL;           // 二叉树初始化为空树
    int i = 0;
    while (i < n)
    {
        // 依次调用BST插入函数，插入数组每个元素
        BSTInsert(T, str[i]);
        i++;
    }
}
```

同一组数字，按照不同的先后顺序，可能构造的二叉树的形状会有区别。
#未完待续 


## 4. BST 的数据删除 
先搜索找到目标结点：
1. 若被删除结点`z`是叶结点，则直接删除，不会破坏二叉排序树的性质。
2. 若结点`z`只有一棵左子树或右子树，则让`z`的子树成为`z`父结点的子树，替代`z`的位置。
3. 若结点`z`有左、右两棵子树，则令`z`的直接后继（或直接前驱）替代`z`，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。
- `z`的后继：`z`的右子树中最左下结点（该节点一定没有左子树）。
- `z`的前驱：`z`的左子树中最右下结点（该节点一定没有右子树）。
#未完待续 

## 5. BST 的效率分析 
查找长度——在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度。
查找成功的平均查找长度 $ASL, Average Search Length$：若树高 $h$，找到最下层的一个结点需要对比 $h$ 次。

- **最好情况**：n个结点的二叉树最小高度为 $⌊log_2{n}⌋+ 1$ 。平均查找长度= $O(log_2{n})$。
- **最好情况**：每一个结点只有一个分支，树高度为h，结点树 n = h，平均查找长度= $O(N)$。

![](img/06_树2/34%20二叉排序树查找成功ASL.jpg)
查找失败的的平均查找长度（ASL）也可以进行计算。

![](img/06_树2/35%20二叉排序树查找失败ASL.jpg)

# [54] 平衡二叉树
平衡二叉树（Balanced Binary Tree），简称平衡树（AVL树），由G. M. Adelson-Velsky和E. M. Landis 于1962年发明。  
AVL树上任一结点的左子树和右子树的高度之差不超过1。即：

> 结点的平衡因子 = 左子树高 - 右子树高。

![](img/06_树2/36%20AVL%20二叉平衡树.jpg)

平衡二叉树结点的平衡因子的值只可能是−1、0或1。
只要有任一结点的平衡因子绝对值大于1，就不是平衡二叉树。
```c
// 平衡二叉树结点
typedef struct AVLNode
{
    int key;            // 数据域
    int balance;        // 平衡因子
    struct AVLNode *lchild, *rchild;
} AVLNode, *AVLTree;
```
## 1. AVL的插入
![[img/06_树2/59 AVL 插入.png]]
在二叉排序树中插入新结点后，查找路径上的所有结点都有可能受到影响，从插入点往回
找到第一个不平衡结点，调整以该结点为根的子树。
上图中，以70为根节点的子树，即是“最小不平衡子树”。
![[img/06_树2/60 调整不平衡子树.png]]

分析得出，调整最小不平衡子树，有以下四种情况：
- 在A的**左孩子**的**左子树**中插入导致不平衡（LL）；
- 在A的**右孩子**的**右子树**中插入导致不平衡（RR）；
- 在A的**左孩子**的**右子树**中插入导致不平衡（LR）；
- 在A的**右孩子**的**左子树**中插入导致不平衡（RL）；

## 2. 调整最小不平衡子树（LL）
如图，使用方框代表一个抽象的子树，高度为H。经过`LL`型插入后左孩子的左子树高度变成了`H+1`。这个时候A的平衡因子由1变成2，导致了不平衡。

![[img/06_树2/61 LL不平衡子树.png]]

在这里使用三个抽象树都是高度H，原因是因为，这里刚好设置的高度满足，LL插入后可以立即形成一个最小不平衡树，可以举例AR的高度是`H+1`试一试即可证明。

【调整方法】**LL平衡旋转**（**右单旋转**）。
二叉排序树的特性：左子树结点值 < 根结点值 < 右子树结点值，所以：`BL<B<BR<A<AR`。
由于在结点A的左孩子（L）的左子树（L）上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作。
将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。

![[img/06_树2/62 LL不平衡子树右旋.png]]

代码实现：
```c
// 假设A的父结点指针是gf，A的结点指针是f，B的结点指针是p。
f->lchild = p->rchild;      // 把BR变成AL
p->rchild = f;              // A成B的右子树
gf->lchild/rchild = p;      // B变成gf的子树
```

## 3. 调整最小不平衡子树（RR）
【调整方法】RR平衡旋转（左单旋转）。

![[img/06_树2/63 RR不平衡子树.png]]

由于在结点A的右孩子（R）的右子树（R）上插入了新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。
将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树。

![[img/06_树2/64 RR不平衡子树左旋.png]]

代码实现：
```c
// 假设A的父结点指针是gf，A的结点指针是f，B的结点指针是p。
f->rchild = p->lchild;      // 把BL变成AR
p->rchild = f;              // A成B的右子树
gf->lchild/rchild = p;      // B变成gf的子树
```

## 4. 调整最小不平衡子树（LR）
【调整方法】**LR平衡旋转**（先左后右双旋转）。
![[img/06_树2/65 LR不平衡子树.png]]
由于在A的左孩子（L）的右子树（R）上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。
1. 先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，
2. 然后再把该C结点向右上旋转提升到A结点的位置。
图中以插入结点在C的右子树CR中，等量换做到CL上依然可以按照相同方法保证调整成功。
![[img/06_树2/66 LR不平衡子树调整.png]]
## 4. 调整最小不平衡子树（LR）
【调整方法】**RL平衡旋转**（先右后左双旋转）。
由于在A的右孩子（R）的左子树（L）上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先**右旋转后左旋转**。
![[img/06_树2/67 RL不平衡子树.png]]
1. 先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置；
2. 然后再把该C结点向左上旋转提升到A结点的位置。
图中以插入结点在C的左子树CL中，等量换做到CH上依然可以按照相同方法保证调整成功。
![[img/06_树2/68 RL不平衡子树调整.png]]

总结只有左孩子才能右上旋，右孩子才能左旋。每次旋转都会导致孩子成为父亲，父亲成为孩子。

在插入结点中，只要将**最小不平衡子树调整平衡**，则其他祖先结点都会恢复平衡。操作导致“最小不平衡子树”高度+1，经过调整后高度恢复。

若树高为h，则最坏情况下，查找一个关键字最多需要对比 h 次，即查找操作的时间复杂度不可能
超过 $O(h)$。
平衡二叉树——树上任一结点的左子树和右子树的高度之差不超过1。
假设以$n_h$表示深度为h的平衡树中含有的最少结点数。
则有$n_0= 0, n_1 = 1, n_2 = 2$，并且有：$$n_h = n_{h−1} + n_{h−2} + 1.$$
可以证明含有n个结点的平衡二叉树的最大深度为$O(log_2n)$，平衡二叉树的平均查找长度为$O(log_2n)$。


