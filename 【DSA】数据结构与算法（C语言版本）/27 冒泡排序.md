
# [79] 冒泡排序
## 1. 算法思想
基于“交换”的排序：根据序列中两个元素关键字的⽐较结果来对换这两个记录在序列中的位置。
交换排序有“冒泡排序”和“快速排序”两种。
## 2. 算法过程
从后往前（或从前往后）两两⽐较相邻元素的值，若为逆序（即`A[i-1]>A[i]`），则交换它们，直到序列⽐较完。称这样过程为“⼀趟”冒泡排序。
第⼀趟：排序使关键字值最⼩的⼀个元素“冒”到最前⾯。
第二趟：前边已经确定最终位置的元素不⽤再对⽐。结束后，最⼩的2个元素会“冒”到最前边。
第二趟：前边已经确定最终位置的元素不⽤再对⽐。结束后，最⼩的3个元素会“冒”到最前边。
.....
若某⼀趟排序没有发⽣“交换”，说明此时已经整体有序。
以第一趟为例：
![[img/09 排序/24 冒泡排序 1.png]]
![[img/09 排序/25 冒泡排序 2.png]]
![[img/09 排序/26 冒泡排序 3.png]]
第⼀趟排序结束，**关键字值最⼩**的⼀个元素“冒”到最前⾯。
![[img/09 排序/27 冒泡排序 4.png]]
![[img/09 排序/28 冒泡排序 5.png]]
![[img/09 排序/29 冒泡排序 6.png]]
第二趟结束后，最⼩的两个元素会“冒”到最前边。
![[img/09 排序/30 冒泡排序 7.png]]
若某⼀趟排序没有发⽣“交换”，说明此时已经整体有序。
当第5趟结束的时候，整个表已经整体有序了，说明不需要再排列了。

冒泡排序中，从后往前（或从前往后）两两⽐较相邻元素的值，若为逆序（即`A[i-1]>A[i]`），则交换它们，直到序列⽐较完。称这样过程为**“⼀趟”冒泡排序**。总共需进⾏ `n-1` 趟冒泡。
## 1. 算法实现
```c
void swap(int &a, int &b){
     int temp = a;
     a = b;
     b = temp; 
}
void BubbleSort(int A[], int n){
    // i 所指位置之前的元素都已“有序”
    for(int i = 0; i < n-1; i++){
        bool flag = false;              // 本趟冒泡是否发生交换的标志
        for(int j = n-1; j > i; j--){     // 一趟冒泡过程
            if(A[j - 1] > A[j]){          // 若为逆序
                swap(A[j - 1],A[j]);      // 交换
                flag = true;
            }
        }
        if(!flag){
            return;                     // 本遍历后没有发生交换，说明表已经有序
        }
    }
}
```
## 4. 算法性能
空间复杂度：$O(1)$
最好情况（有序）：⽐较次数=$n-1$; 交换次数=0  最好时间复杂度 = $O(N)$
最坏情况（逆序）：⽐较次数=$(n-1)+(n-2)+…+1$ = $\frac{n(n-1)}{2}$ = 交换次数 最坏时间复杂度 = $O(N^2)$
平均时间复杂度：$O(N^2)$

注意：`swap(a,b)`每次交换都需要移动元素3次
冒泡排序**同样适⽤于链表**，可从前往后“冒泡”，每⼀趟将更⼤的元素“冒”到链尾。