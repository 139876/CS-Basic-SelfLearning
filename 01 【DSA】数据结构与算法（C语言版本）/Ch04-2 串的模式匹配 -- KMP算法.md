#数据结构  #算法  #C 

# [35]   KMP算法
由D.E.Knuth，J.H.Morris和V.R.Pratt提出，因此称为 KMP算法，该算法对朴素模式匹配算法优化而得。
## 1. 场景复现
**场景**：
已知模式串 `T`,`S` , 循环中，遍历串字符，当第i（i > 1）个元素匹配失败时,第 i 个元素之前的元素是已经匹配成功的。

![](img/Ch04%20串/11%20子串匹配%20匹配失败.jpg)

对于朴素模式匹配算法而言，这些已经匹配成功的字符将会被直接舍去。
如何对该算法进行优化？

![](img/Ch04%20串/46%20模式匹配算法优化.png)

对于已知模式串 T = ‘abaabc’，主串的元素是未知的。对**适配情况进行列举**： 
- 当**第6个**元素匹配失败时，可令主串指针 i **不变**，模式串指针 `j=3` 
- 当**第5个**元素匹配失败时，可令主串指针 i **不变**，模式串指针`j=2` 
- 当**第4个**元素匹配失败时，可令主串指针 i **不变**，模式串指针 `j=2` 
- 当**第3个**元素匹配失败时，可令主串指针 i **不变**，模式串指针`j=1` 
- 当**第2个**元素匹配失败时，可令主串指针 i **不变**，模式串指针 `j=1` 
- 当**第1个**元素匹配失败时，**匹配下⼀个相邻⼦串**，令 `j=0, i++, j++;`

## 2. 算法优化
下面以主串`S = "abaacaabcabaabc"`，模式串`T="abaabc"`为例。使用优化后的算法进行字符串匹配：

![](img/Ch04%20串/47%20KMP优化1.png)
![](img/Ch04%20串/48%20KMP优化2.png)
![](img/Ch04%20串/49%20KMP优化3.png)

![](img/Ch04%20串/50%20KMP优化4.png)
![](img/Ch04%20串/51%20KMP优化5.png)

![](img/Ch04%20串/52%20KMP优化6.png)
![](img/Ch04%20串/53%20KMP优化7.png)

进行匹配过程中，**主串指针不回溯**。  
下一步，如何确定匹配过程失败时候，主串指针的位置？  
解决方式：利用穷举方式，将主串匹配失败i位置与模式串指针j位置建立数组。称之为`next`数组。

![](img/Ch04%20串/54%20next数组.png)

当匹配失败过程时，`i`指针从未往前回溯，`next`数组指明`j`指针的下个位置。

## 3. 程序实现
**总结**：KMP算法，根据模式串`T`，求出 `next` 数组，利⽤`next`数组进⾏匹配,`next`数组只和短的模式串有关，和⻓的主串⽆关。

```c
// KMP算法实现
int Index_KMP(StaticString S, StaticString T, int next[]){
    int i = 1, j = 1;
    while(i <= S.length && j <= T.length){
        if(j==0 || S.ch[i] == T.ch[j]){
            ++i;
            ++j;            // 继续比较后继字符
        } else {
            j = next[j];    // 模式串向右移动
        }
    }
    if(j > T.length){
        return i - T.length;
    } else {
        return 0;
    }
}
```
## 4. 算法评价
最坏时间复杂度 $O(m + n)$  
其中，求 `next` 数组时间复杂度 $O(m)$  
模式匹配过程最坏时间复杂度 $O(n)$  

# [36] 求KMP算法的`next`数组
根据模式串`T`，求出 `next` 数组。  
**`next`数组的作⽤**：**当模式串的第 j 个字符失配时，从模式串的第** `next[j]` **的继续往后匹配。**  
**问题**：现在求`next`数组的具体元素是多少，以模式串`"google"`为例。

![](img/Ch04%20串/55%20求next数组.png)

## 1. 求`next[1]`的值
任何模式串都⼀样，第1个字符不匹配时，只能匹配下⼀个⼦串，因此，往后，`next[1]`都⽆脑写 0。然后再继续执行以下程序：
```c
if (j == 0) { 
    i++; 
    j++; }
```

![](img/Ch04%20串/56%20next[1].png)

## 2. 求`next[2]`的值
任何模式串都⼀样，第2个字符不匹配时，应尝试匹配模式串的第1个字符，因此，往后，`next[2]`都⽆脑写 1。

![](img/Ch04%20串/57%20next[2].png)

## 3. 求`next[3]`的值
在不匹配的位置前边，**划⼀根分界线**，模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为⽌。   
此时 `j` 指向哪⼉，`next`数组值就是多少。
对于模式串`"google"`，`next[3]` = 1。

![](img/Ch04%20串/58%20next[3].png)

## 4. 求`next[4]`的值
在不匹配的位置前边，**划⼀根分界线**，模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为⽌。 
此时 `j` 指向哪⼉，`next`数组值就是多少。
对于模式串`"google"`，`next[4]` = 1。

![](img/Ch04%20串/59%20next[4].png)

## 5. 求`next[5]`的值
在不匹配的位置前边，**划⼀根分界线**，模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为⽌。   
此时 `j` 指向哪⼉，`next`数组值就是多少。
对于模式串`"google"`，`next[5]` = 2。

![](img/Ch04%20串/60%20next[5].png)

## 6. 求`next[6]`的值
在不匹配的位置前边，**划⼀根分界线**，模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为⽌。 
此时 `j` 指向哪⼉，`next`数组值就是多少。
对于模式串`"google"`，`next[6]` = 1。

![](img/Ch04%20串/61%20next[6].png)

## 7. 总结
`next[1] = 0` ，`next[2] = 1` 。   
其他 `next[i]`：在不匹配的位置前，划⼀根分界线；模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为止。此时 `j` 指向哪⼉，`next`数组值就是多少。