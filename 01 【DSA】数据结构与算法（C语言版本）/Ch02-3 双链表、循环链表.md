#数据结构 #C 

# [16] 双链表
为什么引入双链表？  
单链表的结点中只有一个指向其后继的指针，使得单链表要访问某个结点的前驱结点时，只能从头开始遍历，访问后驱结点的复杂度为`O(1)`，访问前驱结点的复杂度为`O(n)`。为了克服上述缺点，引入了双链表。

![](img/Ch02%20线性表/22%20单链表与双链表.JPG)

**对于单链表**：

一个节点，有储存数据的data，和next后驱节点(指针)。也就是这个单链表想要一些遍历的操作都得通过前节点索引到后节点。

**对于双链表**：

对于一个节点，有些和单链表一样有存储数据的data，指向后方的next（指针）。它拥有单链表的所有操作和内容。但是他还有一个前驱节点pre(指针)。

```cpp
// 声明
typedef struct DNode {
    ElemType data;
    struct DNode *prior, *next;
} DNode, *DLinklist;
```

![](img/Ch02%20线性表/23%20双链表节点.JPG)

## 1.初始化
双链表的初始化，一般默认带头结点：

![](img/Ch02%20线性表/24%20双链表初始化%20带头结点的双链表.JPG)

```cpp
// 初始化双链表
bool InitDLinklist(Dlinklist &L)
{
    L = (DNode*)malloc(sizeof(DNode));
    if (L == NULL) {
        return false;
    }

    // 头结点的 prior 永远指向 NULL
    L->prior = NULL;
    L->next = NULL;
    return true;
}

void testDLinkList(){
    DLinkList L;
    InitDLinkList (L);
    /* ...后续代码... */
}
```

如何对一个双链表判空？下一条指针为空
```cpp
bool Empty(DLinkList L)
{
    if (L->next == NULL){
        return true;
    } else {
        return false;
    }
}
```

## 2.插入
插入时需要考虑其后是否有后继结点，如果没有后继结点，会容易产生问题

```c
// 在p结点后插入s结点
bool InsertNextDNode(DNode *p, DNode *s)
{
    // 非法参数
    if (p == NULL || s == NULL){
        return false;
    }
    // 注意以下四个步骤的顺序
    s->next = p->next;
    // 如果p结点后有后继结点
    if (p->next != NULL){
        p->next-prior = s;
    }
    s->prior = p;
    p->next = s;
    return true;
}
```
`InsertNextDNode(DNode *p,DNode *s)`是函数原型，按位序插入和前插操作都是它的变式。
1. 按位序插入，以头结点开始，找到一个位置i的前驱结点，对前驱结点进行后插操作；
2. 前插操作，对这个结点的前一位，进行后插操作。

## 3.删除

```c
// 删除p的后继结点q
bool DeleteNextDNode(DNode *p)
{
    // 判空
    if (p == NULL){
        return false;
    }
    // 找到p的后继结点q，如果判空表示没有后继结点，删除失败
    DNode *q = p->next;
    if (q == NULL){
        return false;
    }
    p->next = q-next;
    // 判断q结点是否最后一个结点
    if (q->next != NULL){
        q->next->prior = p;
    }
    free(p);
    return true;
}
```

如何销毁双链表？ 使用while循环，对头结点后的每个结点进行删除。
```c
void DestroyList(DLinkList &L)
{
    // 循环释放各个数据结点
    while(L->next != NULL)
    {
        DeleteNextNode(L);
    }
    free(L);        // 释放头指针
    L = NULL;       // 头指针指向NULL
}
```
## 4.遍历
双链表指针有前向遍历和后向遍历
```c
// 后向遍历
while (p != NULL)
{
    p = p->next;
    /*对结点进行处理，例如打印，取值等*/
}
```

```c
// 前向遍历
while (p != NULL)
{
    p = p->prior;
    /*对结点进行处理，例如打印，取值等*/
}
```

如果不针对头结点
```c
// 前向遍历,跳过头结点
while (p->prior != NULL)
{
    p = p->prior;
    /*对结点进行处理，例如打印，取值等*/
}
```
双链表不可随机存取，按位查找、按值查找操作都只能用遍历的方式实现，时间复杂度`O(n)`。

# [17] 循环链表
循环链表分循环单链表和循环双链表：

![](img/Ch02%20线性表/27%20循环链表.jpg)

## 1.循环单链表
单链表：表尾结点的`next`指针指向 `NULL`
循环单链表：表尾结点的`next`指针指向头结点
```c
typedef struct LNode {           // 定义单链表结点类型
    ElemType data;              // 每个结点存放一个数据元素
    struct LNode *next;         // 指针指向下一个结点
} LNode, *LinkList;

// 初始化一个循环单链表
bool InitList(LinkList &L) 
{
    // 分配头结点
    L = (LNode*) malloc(sizeof(LNode));
    // 判断是否分配成功
    if (NULL == L){
        return false;
    }

    // 头结点next指向头结点自身
    L->next = L;
    return true;
}
```

如何判断结点是否为循环单链表的表尾？
```c
bool isTail(LinkList L, LNode *p)
{
    if (p->next == L) {
        return true;
    } else {
        return false;
    }
}
```
- 单链表：从一个结点出发，只能找到后续的各个结点
- 循环单链表：从一个结点出发，可以找到其他任何一个结点

## 2.循环双链表
- 双链表：表头结点的 prior 指向 NULL；表尾结点的 next 指向 NULL
- 循环双链表：表头结点的 prior 指向表尾结点；表尾结点的 next 指向头结点
```c
// 声明
typedef struct DNode {
    ElemType data;
    struct DNode *prior,*next;
}DNode, *DLinklist;

// 初始化空的双链表
bool InitDLinklist(Dlinklist &L)
{
    L = (DNode*)malloc(sizeof(DNode));
    if (L == NULL) {
        return false;
    }
    
    L->prior = L;       // 头结点的 prior 指向头结点
    L->next = L;        // 头结点的 next 指向头结点
    return true;
}

void testDLinkList()
{
    DLinkList L;
    InitDLinkList (L);
    /* 后续代码 */
}
```

如何对一个双链表判空？
```c
// 双链表判空
bool Empty(DLinkList L)
{
    if (L->next == L) {
        return true;
    } else {
        return false;
    }
}
```

如何判断结点是否为循环双链表的表尾
```c
// 双链表判尾结点
bool isTail(DLinkList L, DNode *p)
{
    if (p->next == L) {
        return true;
    } else {
        return false;
    }
}
```

```c
// 双链表的插入，在p结点后插入s结点
bool InsertNextDNode()
{
    s->next = p->next;  // 把结点*s 插到结点*p 后面
    p->next->prior = s;  // 这句不需要条件判定了
    s->prior = p;
    p->next = s;
    return true;
}
```

```c
// 双链表的删除，删除p结点后插入q结点
p->next = q-next;
q->next->prior = p;
free(p);
```

# [18] 静态链表
## 1.静态链表与单链表的区别
- 单链表：各个结点在内存中星罗棋布、散落天涯。
- 静态链表：分配一整片连续的内存空间，各个结点集中安置。
  每个结点包含**数据元素**和**下一个结点的数组下标**(游标)
  每个数据元素 4B，每个游标 4B（每个结点共 8B）。
  设起始地址为 addr，e1 的存放地址为 addr + 8*2

## 2.代码实现
```c
// 声明
#define MaxSize 10          // 静态链表最大长度
typedef struct {            // 静态链表结构类型定义
    ElemType data;          // 存储数据元素
    int next;               // 下一个元素的数组下标
} SLinkList[MaxSize];        // 静态链表

// 初始化
void testSlinkList()
{
// a是一个静态链表,本质是一个结构体数组,sizeof(a)=80;
    SLinkList a;            
    /* 后续代码 */
}
```

- 静态链表实际上使用数组方式实现的链表
优点： 增删 操作不需要大量移动元素
缺点： 不能随机存取，只能从头结点开始依次往后查找，容量固定不可变

- 适用场景：
1. 不知处指针的低级语言；
2. 数据元素数量固定不变的场景（如操作系统 文件分配表FAT）

# [19] 顺序表和链表的比较
## 1.逻辑结构
都属于线性表，都是线性结构。

## 2.存储结构
1. 顺序表
   优点：支持随机存取、存储密度高
   缺点：大片连续空间分配不方便，改变容量不方便

2. 线性表
   优点：离散的小空间分配方便，改变容量方便
   缺点：不可随机存取，存储密度低

## 3.基本操作 -- 创、销、增、删、改、查
1. 创
- 顺序表：需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源
	静态分配：静态数组；容量不可改变；
	动态分配：动态数组（`malloc()`、`free()`）；容量可改变，但需要移动大量元素，时间代价高。
- 链表：只需分配一个头结点（也可以不要头结点，只声明一个头指针），之后方便拓展

2. 销
- 顺序表：修改 Length = 0
	静态分配：静态数组 系统自动回收空间
	动态分配：动态数组（malloc、free），需要手动 free
- 链表：依次删除各个结点（free）

3. 增删
- 顺序表：插入/删除元素要将后续元素都后移/前移，时间复杂度 `O(n)`，时间开销主要来自移动元素，
  若数据元素很大，则移动的时间代价很高
- 链表：插入/删除元素只需修改指针即可，时间复杂度 `O(n)`，时间开销主要来自查找目标元素，查找元素的时间代价更低

4. 查
- 顺序表：按位查找：`O(1)`，按值查找：`O(n)`
	若表内元素有序，可在$O(\log_{2}{n})$ 时间内找到
- 链表：按位查找：`O(n)`，按值查找：`O(n)`

>总结：
>表长难以预估、经常要增加/删除元素 ——链表
>表长可预估、查询（搜索）操作较多 ——顺序表


