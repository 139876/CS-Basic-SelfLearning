#数据结构 #C 
# [45] 线索二叉树的概念
## 1.二叉树遍历导致数据关系“线性化”
对二叉树进行遍历，原本的非线性关系，经过遍历之后，得到了线性关系。  
例如，如下的二叉树经过中序遍历后，形成了`DBEAFCG`的线性关系。

![](img/06_树2/01%20数据非线性转线性.jpg)

需要明确的是，二叉树作为一种数据结构，其本身的一个节点，对应**唯一前驱和多个后继**。基于遍历序列线性化处理，每个节点只有唯一一个前驱和后继。

![](img/06_树2/02%20线性化前驱后继关系变化.jpg)

【问题】  
能否从二叉树的某个指定节点（非根节点）开始，开始遍历序列？例如二叉树如图，给出指向结点`G`的指针`ptr`，能否对整个二叉树进行中序遍历？

![](img/06_树2/03%20指定节点遍历序列.jpg)

【回答】  
答案很显然是不可以的。因为二叉树的节点的指向是单向，节点的指向是指向它的孩子，而并非指向双亲。对于树的遍历，只能从根节点开始。

## 2.如何对指定节点求二叉树遍历序列

假如，将遍历序列以线性表的形式存储起来，那么，对于任一个给定的元素，都可以找到该数据结构的其他要素（查询线性表）。

【问题】
1. 如何找到指定结点`p` 在中序遍历序列中的前驱 `predecessor`？
2. 如何找到 `p` 的中序后继`successor`？

【思路】  
从根节点出发，重新进行一次中序遍历，指针 `q` 记录当前访问的结点，指针 `pre` 记录上一个被访问的结点。
1. 当`q == p`时，pre为前驱；
2. 当`pre == p`时，q为后继。  

```c
typedef struct BiTNode {
    int data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

void InOrder(BiTree T) {
    if (T != NULL) {
        InOrder(T->lchild);     // 递归遍历左子树
        visit(T);               // 访问根节点
        InOrder(T->rchild);     // 递归遍历右子树
    }
}

BiTree FindPresuc()
{

}

BiTree FindSuc()
{

}
```
**缺点**：找前驱、后继很不方便，操作必须从根开始，从头开始遍历。

## 3.线索二叉树
对原普通二叉树观察发现，存储空间内存在很多空链域，这些空链域可以用来指向他们的前驱和后继。可以利用叶子节点的空链域，分别指向他们的前驱和后继。这个过程叫做二叉树的线索化（Threading）。

![](img/06_树2/04%20线索二叉树.jpg)

这个时候，对原二叉树进行改造的产物叫做线索二叉树（Threaded BinaryTree），又叫引线二元树、引线二叉树。  
改造后的二叉树，对于某个节点而言，找到其前驱和后继只需要通过**前驱线索**和**后继线索**即可。
## 4.线索二叉树的存储结构
线索二叉树是添加了直接指向节点的前驱和后继的指针的二叉树。

```c
// 二叉树的结点（链式存储）
typedef struct BiTNode {
    ElemType data;
    BiNode *lchild, *rchild;
} BiTNode, *BiTree;

// 线索二叉树的结点
typedef struct ThreadNode {
    ElemType data;
    ThreadNode *lchild, *rchild;
    int ltag, rtag;        // 左、右线索标志
} ThreadNode, *ThreadTree;
```

当`tag == 0`，表示指针指向孩子；当`tag == 1`，表示指针指向线索。
二叉树可以叫做二叉链表，线索二叉树可以叫做线索链表。
上图中的原二叉树，可以直接转化成以下的形式：

![](img/06_树2/05%20二叉树线索化.jpg)

同理，中序遍历二叉树序列的线索化，可以推广到前序线索二叉树、后序线索二叉树。

![](img/06_树2/06%20先序遍历线索二叉树.jpg)
![](img/06_树2/07%20后序遍历线索二叉树.jpg)

- **中序线索二叉树** —— 线索指向**中序前驱**、**中序后继**；
- **先序线索二叉树** —— 线索指向**先序前驱**、**先序后继**；
- **后序线索二叉树** —— 线索指向**后序前驱**、**后序后继**。

# [46] 二叉树的线索化
## 1.中序线索化
回顾对普通二叉树进行某一个结点求其前驱的过程：

![](img/06_树2/08%20中序遍历线索二叉树.jpg)

```c
// 中序遍历寻找前驱
void FindPreNode(BiTree T) 
{
    if (T != NULL){
        InOrder(T->lchild);    // 递归遍历左子树
	    visit(T);              // 访问根节点
        InOrder(T->rchild);    // 递归遍历右子树
    }
}

// 访问结点q
void visit(BiTree T) 
{
    if (q == p) {           // 如果临时变量刚好访问到p
        final = pre;        // 找到p的前驱
    } else {
        pre = q;            // pre 指向当地访问的结点
    }
}

// 辅助全局变量，用于查找结点p的前驱
BiTNode *p;                 // p指向目标节点；
BiTNode *pre;               // pre指向当前节点的前驱；
BiTNode *final = NULL;      // final用于记录最终结果；
```

如果使用线索二叉树：
```c
typedef struct ThreadNode {
    ElemType data;
    ThreadNode *lchild, *rchild;
    int ltag, rtag;        // 左、右线索标志
} ThreadNode, *ThreadTree;

// 中序遍历二叉树，一边遍历一边线索化
void InThread(ThreadTree T) 
{
    if (T != NULL) {
        InTread(T->lchild);        // 中序遍历左子树
        visit(T);                // 访问根节点
        InTread(T->rchild);        // 中序遍历右子树
    }
}

// 线索化
void visit(ThreadNode *q) 
{
    // 左子树是空
    if (q->lchild == NULL) {
        q->lchild = pre;
        q->ltag = 1;
    }
    if (pre != NULL && pre->rchild == NULL) {
        pre->rchild = q;    // 建立前驱结点的后继线索
        pre->rtag = 1;
    }
    // 把pre指状指向下一个结点，依次遍历
    pre = q;
}
// 全局变量pre, 指向当前访问结点的前驱
ThreadNode *pre = NULL;
```
最后要继续检查pre的rchild是否是NULL，如果是的话，令`rtag` = 1.
中序线索化的过程，调用`InThread`函数：
```c
// 全局变量 pre， 指向当前访问结点的前驱
ThreadNode *pre = NULL;

// 中序线索化二叉树
void CreateInThread(ThreadNode T) 
{
    pre = NULL;                // pre初始化为NULL
    if (T != NULL) {        // 非空二叉树才能线索化
        InThread(T);        // 中序线索化二叉树
        if (pre->rchild == NULL){
            pre->rtag = 1;    // 处理遍历的最后一个结点
        }
    }
}

// 调用函数： CreateInThread --> InThread --> visit
```

中序线索化其实就是对树的中序遍历，只不过在visit当中，添加了线索化过程。但是对于最后一个右孩子的结点后驱进行特殊处理。

![](img/06_树2/05%20二叉树线索化.jpg)

还可以使用递归调用直接实现线索化的过程：
```c
// 中序线索化，这里的pre是一个引用类型
void InThread(ThreadTree p, ThreadTree &pre)
{    
    if(p != NULL) {    
        InThread(p->lchild, pre);    // 递归，线索化左子树
        // 处理根节点
        if (p->lchild == NULL) {    // 左子树为空，建立前驱线索
            p->lchild = pre;        
            p->ltag = 1;
        }
        if (pre != NULL && pre->rchild == NULL) {
            // 右子树为空，建立前驱结点的后继线索
            pre->rchild = p;        
            pre->rtag = 1;
        }
        InThread(p->rchild, pre);    // 递归，线索化右子树
    }
}
```

【思考】
为什么处理遍历最后一个结点时，不判断`rchild`是否为`NULL`？
【解释】
因为中序遍历的最后一个结点右孩子指针必为空。

## 2.先序线索化

![](img/06_树2/06%20先序遍历线索二叉树.jpg)

```c
// 先序遍历二叉树，一边遍历一边线索化
void PreThread(ThreadTree T)
{
    if (T != NULL) {
        visit(T);            // 先处理根节点
        if (T-> ltag == 0)    // lchild 不是前驱线索
        {
            PreThread(T->lchild);
        }
        PreThread(T->rchild);
    }
}

// 线索化
void visit(ThreadNode *q) 
{
    // 左子树是空，建立前驱线索
    if (q->lchild == NULL) {
        q->lchild = pre;
        q->ltag = 1;
    }
    if (pre != NULL && pre->rchild == NULL) {
        pre->rchild = q;    // 建立前驱结点的后继线索
        pre->rtag = 1;
    }
    // 把pre指状指向下一个结点，依次遍历
    pre = q;
}
// 全局变量pre, 指向当前访问结点的前驱
ThreadNode *pre = NULL;

void PreThread(ThreadTree T)
{
    if (T != NULL) {
        visit(T);            // 先处理根节点
        if (T-> ltag == 0)    // lchild 不是前驱线索
        {
            PreThread(T->lchild);
        }
        PreThread(T->rchild);
    }
}

// 先序线索化二叉树
void CreatePreThread(ThreadNode T) 
{
    pre = NULL;                // pre初始化为NULL
    if (T != NULL) {        // 非空二叉树才能线索化
        PreThread(T);        // 中序线索化二叉树
        if (pre->rchild == NULL){
            pre->rtag = 1;    // 处理遍历的最后一个结点
        }
    }
}

```
在先序二叉树线索化过程中，如果不采取`if (T-> ltag == 0)`判定的话，对其指向结点访问，有可能访问前驱结点，造成死循环问题。

## 3.后序线索化

![](img/06_树2/07%20后序遍历线索二叉树.jpg)

```c
// 后序遍历二叉树，一边遍历一边线索化
void PostThread(ThreadTree T) 
{
    if (T != NULL) {
        PostThread(T->lchild);        // 后序遍历左子树
        PostThread(T->rchild);        // 后序遍历右子树
        visit(T);                    // 访问根节点
    }
}

// 线索化
void visit(ThreadNode *q) 
{
    // 左子树是空，建立前驱线索
    if (q->lchild == NULL) {
        q->lchild = pre;
        q->ltag = 1;
    }
    if (pre != NULL && pre->rchild == NULL) {
        pre->rchild = q;    // 建立前驱结点的后继线索
        pre->rtag = 1;
    }
    // 把pre指状指向下一个结点，依次遍历
    pre = q;
}
// 全局变量pre, 指向当前访问结点的前驱
ThreadNode *pre = NULL;

// 后序线索化二叉树T
void CreatePostThread(ThreadNode T) 
{
    pre = NULL;                // pre初始化为NULL
    if (T != NULL) {        // 非空二叉树才能线索化
        PostThread(T);        // 中序线索化二叉树
        if (pre->rchild == NULL){
            pre->rtag = 1;    // 处理遍历的最后一个结点
        }
    }
}
```
后序线索化并不会出现类似先序线索化的“死循环”问题。

# [47] 在线索二叉树中找前驱后继
二叉树的线索化，最终目的时为了找到遍历序列的前驱和后继，以下讲着重探讨在不同类型的线索二叉树下，怎么找前驱和后继。

## 1. 中序线索二叉树找中序后继
【问题】中序线索二叉树，如何找到指定结点 `*p` 的中序后继 `next`？
1. 若 `p->rtag == 1`，则`next = p->rchild`（中序遍历：左-->根--> 右，如果`rtag`值表示1，即表示该叶子结点有后继线索，直接赋值即可）;
2. 若 `p->rtag == 0`，表示这个结点一定是有右孩子的，`next = p的右子树中最左下的结点`。
![[img/06_树2/46 中序线索二叉树后继.png]]
代码实现：
```c
// 函数调用：InOrder --> NextNode --> FirstNode
// 对中序线索二叉树进行中序遍历(利用线索实现的非递归算法)
void InOrder(ThreadNode *T)
{
    for(ThreadNode *p = FirstNode(T); p != NULL; 
        p = NextNode(p)){
        visit(p);
    }
}

// 中序线索二叉树中找到结点p的后继结点
ThreadNode *NextNode(ThreadNode *p)
{
    // 右子树中最左下结点
    if (p->rtag == 0){
        return FirstNode(p->rchild);
    } else {
        // rtag == 1 直接返回后继线索。
        return p->rchild;
    }
}

// 找到以P为根的子树，第一个被中序遍历的结点
ThreadNode *FirstNode(ThreadNode *p)
{
    // 循环找到最左下结点(不一定是叶结点)
    while (p->ltag == 0){
        p = p->lchild;
    }
    return p;
}
```

## 2. 中序线索二叉树找中序前驱
【问题】中序线索二叉树，如何找到指定结点 `*p` 的中序前驱 `pre`？
① 若 `p->ltag == 1`，则`pre = p->lchild`（中序遍历：左-->根--> 右，如果`ltag`值表示1，即表示该叶子结点有前驱线索，直接赋值即可）;
② 若 `p->ltag == 0`，表示这个结点一定是有左孩子的，`next = p的左子树中最右下的结点`。
![[img/06_树2/47 中序线索二叉树前驱.png]]
```c
// 对中序线索二叉树进行逆向中序遍历(利用线索实现的非递归算法)
void ReverseInOrder(ThreadNode *T)
{
    for(ThreadNode *p = LastNode(T); p != NULL; 
        p = PreNode(p)){
        visit(p);
    }
}

// 中序线索二叉树中找到结点p的前驱结点
ThreadNode *PreNode(ThreadNode *p)
{
    // 左子树中最右下结点
    if (p->rtag == 0){
        return LastNode(p->lchild);
    } else {
        // ltag == 1 直接返回后继线索。
        return p->lchild;
    }
}

// 找到以P为根的子树，最后一个被中序遍历的结点
ThreadNode *LastNode(ThreadNode *p)
{
    // 循环找到最右下结点(不一定是叶结点)
    while (p->rtag == 0){
        p = p->rchild;
    }
    return p;
}
```

## 3. 先序线索二叉树找先序后继
【问题】先序线索二叉树（根节点--> 左孩子 --> 右孩子），如何找到指定结点 `*p` 的先序后继 `next`？
1. 若 `p->rtag == 1`，同理，则`next = p->rchild`;
2.  若 `p->rtag == 0`，表示这个结点一定是有右孩子的。
这个时候，需要对这个结点的左孩子情况进行讨论。
- 如果有左孩子，那么先序后继为左孩子；
- 如果有没有左孩子，那么先序后继为右孩子。
![[img/06_树2/48 先序线索二叉树后继.png]]
```c
// 找先序线索二叉树p的后继
ThreadNode *FindNext(ThreadNode *p){
    if (p->rtag == 1){
        return p->rchild;
    } else if (p->ltag == 0){
        return p->lchild;
    } else {
        return p->rchild;
    }
}
```

## 4. 先序线索二叉树找先序前驱
先序遍历：某一个结点的前驱左右子树只可能是它的后继，均不可能是它的前驱，所以，可以使用最原始的方式从根节点依次遍历。
或者采取三叉链表的数据结构，分配一个指针，用于指向该结点的父结点。

如果采取后者，就需要对具体情况进行分类**逐个讨论**了：
![[img/06_树2/49 先序线索二叉树前驱.png]]

- 情形1：如果能找到p的父节点，且p是左孩子。父结点是前驱。
- 情形2：如果能找到p的父节点，且p是右孩子，其左兄弟为空。父结点是前驱。
- 情形3：如果能找到p的父节点，且p是右孩子且左孩子不为空。**左兄弟子树最后一个被先序遍历的结点**是前驱。
- 情形4：没有父节点。没有前驱。

## 5. 后序线索二叉树找后序前驱
【问题】后序线索二叉树，如何找到指定结点 `*p` 的中序前驱 `pre`？
① 若 `p->ltag == 1`，则`pre = p->lchild`（同理）;
② 若 `p->ltag == 0`，表示这个结点一定是有左孩子的。
这个时候，需要对这个结点的左孩子情况进行讨论。
- 如果有右孩子，那么后序前驱为右孩子；
- 如果没有右孩子，那么后序前驱为左孩子；
![[img/06_树2/50 后序线索二叉树前驱.png]]
```c
// 找后序线索二叉树p的前驱
ThreadNode *FindPre(ThreadNode *p){
    if (p->rtag == 1){
        return p->lchild;
    } else if (p->rtag == 0){
        return p->rchild;
    } else {
        return p->lchild;
    }
}
```

## 6. 后序线索二叉树找后序后继
后序遍历：某一个结点的后驱左右子树只可能是它的前驱，均不可能是它的后继，所以，可以使用最原始的方式从根节点依次遍历。
或者采取三叉链表的数据结构，分配一个指针，用于指向该结点的父结点。

如果采取后者，同样需要对具体情况进行分类**逐个讨论**了：
![[img/06_树2/51 后序线索二叉树后继.png]]

- 情形1：如果能找到p的父节点，且p是右孩子。父结点是后继。
- 情形2：如果能找到p的父节点，且p是左孩子，其右兄弟为空。父结点是后继。
- 情形3：如果能找到p的父节点，且p是左孩子且右孩子不为空。**右兄弟子树第一个被后序遍历的结点是后继**是后继。
- 情形4：没有父节点。没有后继。
