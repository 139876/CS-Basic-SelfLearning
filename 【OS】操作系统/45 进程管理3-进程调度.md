#操作系统 
# [15] 调度的概念、层次
当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来**决定**处理**这些任务的顺序**，这就是“**调度**”（schedule，dispatcher）研究的问题。

![](img/02_process_mngmnt/22%20调度的例子.jpg)

使用CPU调度机制**可以解决以下问题**：
1. 如果进程正在等待执行，请尽可能使 CPU 保持繁忙状态。
2. 缩短关键流程的执行时间。
3. 智能地确定执行流程的优先级。
4. 将响应时间保持在最低限度。

广义的调度分为三级调度——高级、中级、低级，又叫长周期、中周期、短周期调度。

![](img/02_process_mngmnt/23%20三级调度.jpg)

## 1.高级调度（long-term scheduling）
高级调度又叫作业调度（Job Scheduler），作业的含义是指**一个具体的任务**。例如，作业是一次完成数据统计，实行一次打印输出等。
高级调度，按一定的原则从**外存的作业后备队列**（后备队列是位于外存中）中挑选一个作业调入**内存**，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。

![](img/02_process_mngmnt/24%20高级调度.jpg)

## 2.低级调度（short-term scheduling）
低级调度又称之为进程调度、处理机调度（CPU scheduling），其注意按照某种策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。

![](img/02_process_mngmnt/25%20低级调度.jpg)

## 3.中级调度（middle-term scheduling）
内存不够时，可将某些**进程的数据调出外存**。等内存空闲或者进程需要运行时再**重新调入内存**。暂时调到外存等待的进程状态为**挂起状态**。被挂起的进程PCB会被组织成**挂起队列**。

![](img/02_process_mngmnt/26%20中级调度.jpg)

因此，中级调度又称之为内存调度（swapping out），即按照某种策略决定将哪个处于**挂起状态**的进程**重新调入内存**。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要**比高级调度更高**。
## 4.进程的挂起态与七状态模型
暂时调到外存等待的进程状态为**挂起状态**（挂起态，suspend），挂起态又可以进一步细分为**就绪挂起**、**阻塞挂起**两种状态。这里，我们使用了七状态模型。

![](img/02_process_mngmnt/07%20进程七状态模型.jpg)

★注意“挂起”和“阻塞”的区别：
两种状态都是暂时不能获得CPU的服务，但**挂起态**是将**进程映像调到外存**去了，而阻塞态下**进程映像还在内存**中。
有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。
## 5.总结

| 调度类型                 | 做的任务                                                             | 调度发生在哪里         | 发生频率 | 对进程状态的影响                 |
| ------------------------ | -------------------------------------------------------------------- | ---------------------- | -------- | -------------------------------- |
| 高级调度（**作业调度**） | 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 外存->内存（面向作业） | 最低     | 无->创建态->就绪态               |
| 中级调度（**内存调度**） | 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存             | 外存->内存（面向进程） | 中等     | 挂起态->就绪态（阻塞挂->阻塞态） |
| 低级调度（**进程调度**） | 按照某种规则，从就绪队列中选择一个进程为其分配处理机                 | 内存->CPU              | 最高     | 就绪态->运行态                   |

# [16] 进程调度的时机、切换与过程、方式
进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。
## 1. 进程调度的时机
什么时候需要进行进程调度与切换的情况？
### 当前运行的进程主动放弃处理机：
1. 进程正常终止;
2. 运行过程中发生异常而终止;
3. 进程主动**请求阻塞**（如 等待I/O）;
### 当前运行进程被动放弃处理机：
4. 分给进程的时间片用完;
5. 有更紧急的事需要处理（如 **I/O中断**）;
6. 有更高优先级的进程进入就绪队列.

![](img/02_process_mngmnt/27%20进程调度发生场景.jpg)

### 不能进行进程调度与切换的情况
1. 在**处理中断的过程**中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。
2. 进程在操作系统内核程序临界区中。
3. 在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）。

![](img/02_process_mngmnt/28%20进程调度不会发生场景.jpg)

错误辨析：
- √ 进程在操作系统**内核程序临界区**中不能进行调度与切换。----- 正确
- × 进程处于**临界区**时不能进行处理机调度。----- 错误

### 临界资源
- **临界资源**：一个时间段内只允许一个进程使用的资源。各进程需要**互斥**地访问临界资源。 
- 临界区：访问临界资源的那段代码。
    **内核程序临界区**一般是用来**访问某种内核数据结构**的，比如进程的就绪队列（由各就绪进程的PCB组成）

![](img/02_process_mngmnt/29%20临界区.jpg)

## 2. 进程调度的方式
1. 非剥夺调度方式，又称非抢占方式（Non-Preemptive Scheduling）。
只**允许进程主动放弃处理机**。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。   
实现简单，系统开销小但是**无法及时处理紧急任务**，适合于早期的**批处理系统**。
2. 剥夺调度方式，又称抢占方式（Preemptive Scheduling）。
当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给**更重要紧迫**的那个进程。    
可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于**分时操作系统、实时操作系统**。

![](img/02_process_mngmnt/30%20抢占式和非抢占式.jpg)

## 3. 进程调度的切换与过程
狭义的“进程调度（process scheduling）”与“进程切换（process switch）”的区别：
- **狭义的进程调度**指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被**暂停执行**的进程，也可能是**另一个进程**，后一种情况就需要进程切换）。
- **进程切换**是指一个进程让出处理机，由另一个进程占用处理机的过程。
- **广义的进程调度**包含了**选择一个进程和进程切换**两个步骤。

- 进程切换的过程实际上完成了：
1. 对原来运行进程各种数据的保存；
2. 对新的进程各种数据的恢复。
（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）

![](img/02_process_mngmnt/31%20上下文切换.jpg)

★注意：
**进程切换是有代价**的，因此如果**过于频繁**的进行进程调度、切换，必然会使**整个系统的效率降低**，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

# [17] 调度算法的评价指标
## 1.CPU利用率（utilization）
CPU利用率：指CPU “忙碌”的时间占总时间的比例。
$$利用率 = \frac{忙碌的时间}{总时间}$$
## 2.系统吞吐量（throughput）
系统吞吐量：单位时间内完成作业的数量。
$$系统吞吐量= \frac{总共完成了多少道作业}{总共花了多少时间}$$
## 3.周转时间（turnarouad time）
周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。它包括四个部分：
1. 作业在外存后备队列上**等待作业调度**（高级调度）的时间；
2. 进程在就绪队列上**等待进程调度**（低级调度）的时间；
3. **进程在CPU上执行的时间**；
4. **进程等待I/O**操作完成的时间。  

![](img/02_process_mngmnt/32%20周转时间.jpg)

后三项在一个作业的整个处理过程中，可能发生多次（**作业调度**只发生一次）。
$$周转时间 = 作业完成时间 – 作业提交时间$$
$$平均周转时间= \frac{各作业周转时间之和}{作业数}$$
对于用户来说，更关心自己的单个作业的周转时间。但是对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值。因此提出**带权周转时间**（weighted turnarouad time）和**平均带权周转时间**。
$$带权周转时间 = \frac{作业周转时间}{作业实际运行的时间} = \frac{作业完成时间 – 作业提交时间}{作业实际运行的时间} $$
带权周转时间与周转时间都是越小越好。
$$平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}$$
对于周转时间相同的两个作业，**实际运行时间长**的作业在相同时间内被服务的时间更多，带**权周转时间更小**，用户满意度更高。对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高。

## 4.等待时间（Waiting time）
计算机的用户希望自己的作业尽可能少的等待处理机等待时间，指进程/作业**处于等待处理机状态时间之和**，**等待时间越长，用户满意度越低**。

![](img/02_process_mngmnt/33%20等待时间.jpg)

- 对于**进程**来说，等待时间就是指进程建立后**等待被服务的时间之和**，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。
- 对于**作业**来说，不仅要考虑建立进程后的等待时间，还要加上**作业在外存后备队列**中等待的时间。   
一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“**平均等待时间**”来评价整体性能。

## 5.响应时间（Response time）
对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。**响应时间**，指从**用户提交请求**到首次**产生响应**所用的时间。

