#操作系统 

# [55] 文件存储空间管理
文件存储空间管理，是指对非空闲空间（已经存放数据空间）和空闲数据空间的管理。其中，对非空闲空间的管理已经在前文中详述了，包含**连续分配、链接分配和索引分配**的方式。这一节，主要探讨，对空闲空间的管理。
## 1.存储空间划分与初始化
安装 Windows 操作系统的时候，一个必经步骤是——为磁盘分区（C: 盘、D: 盘、E: 盘等）。
- 存储空间的划分：将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）；
- 存储空间的初始化： 将各个文件卷划分为目录区、文件区。
	目录区主要存放文件目录信息（FCB）、用于磁盘存储空间管理的信息；
	文件区用于存放文件数据。 

## 2.空闲表法
空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。如下图中，彩色框内表示空闲磁盘块，黑色框内表示已经使用磁盘块：

![空闲表法](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95.png)

当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。当用户撤销一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。
这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。

## 3.空闲链表法
我们也可以使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来。如下图：

![空闲链表法](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%A9%BA%E9%97%B2%E5%9D%97%E9%93%BE%E8%A1%A8.png)

当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。这种技术只要在主存中保存一个指针，令它指向第一个空闲块。
其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I/O 操作，同时数据块的指针消耗了一定的存储空间。
空闲表法和空闲链表法**都不适合用于大型文件系统**，因为这会使空闲表或空闲链表太大。

## 4.位图法
位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。
当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：

```
1111110011111110001110110111111100111 ...
```

在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。

## 5.成组链接法
空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了成组链接法(Group link)对磁盘空闲块进行管理。 文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的“超级块”数据一致。

# [56] 文件的基本操作
## 1.创建文件(create 系统调用)
进行`Create`系统调用时，需要提供的几个主要参数： 
1. 所需的外存空间大小（如：一个盘块，即1KB） 
2. 文件存放路径（“D:/Demo”） 
3. 文件名（这个地方默认为“新建文本文档.txt”） 

操作系统在处理`Create`系统调用时，主要做了两件事： 
1.在外存中找到文件所需的空间（结合空闲链表法、位示图、成组链接法等管理策略，找到空闲空间）; 
2.根据文件存放路径的信息找到该目录对应的目录文件（此处就是D:/Demo目录），在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。

## 2.删除文件(delete 系统调用)
进行`Delete`系统调用时，需要提供的几个主要参数： 
1. 文件存放路径（“D:/Demo”） 
2. 文件名（“test.txt”） 

操作系统在处理`Delete`系统调用时，主要做了几件事： 
1. 根据文件存放路径找到相应的目录文件，从目 录中找到文件名对应的目录项。 
2. 根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。（回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）。 
3. 从目录表中删除文件对应的目录项。

## 3.打开文件(open 系统调用)
在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用 “打开文件”，需要提供的几个主要参数： 
1.文件存放路径（“D:/Demo”） 
2.文件名（“test.txt”） 
3.要对文件的操作类型（如：r只读； rw读写等） 

操作系统在处理`open`系统调用时，主要做了几件事： 
1.根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限。 
2.将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。

![](img/04_file_mngmnt/12%20文件描述符与打开文件描述符.jpg)

系统的**打开文件表**（open file table，整个系统只有一张），记录此时有多少个进程打开了多少个文件，可以方便实现某些文件管理的功能。

> 在Windows系统中，我们尝试删除某个txt文件，如果此时该文件已被某个“记事本” 进程打开，则系统会提示我们“暂时无法删除该文件”。其实系统在背后做的事就 是先检查了系统打开文件表，确认此时是否有进程正在使用该文件。

## 4.关闭文件(close 系统调用)
进程使用完文件后，要“关闭文件”：
操作系统在处理 `Close` 系统调用，主要完成几件事：
1. 将进程的打开文件表相应的表项删除；
2. 回归分配给该文件的内存空间等资源；
3. 系统打开文件表的打开计数器 count 减 1，若将 count = 1，则删除对应的表项。

## 5. 读文件(read 系统调用)
进程使用 `read` 系统调用完成写操作。需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要读入多少数据（如：读入1KB）、指明读入的数据要放在内存中的什么位置。 

操作系统在处理`read`系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。

## 6. 写文件(write 系统调用)
进程使用`write`系统调用完成写操作。需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要写出多少数据（如：写出1KB）、写回外存的数据放在内存中的什么位置。

操作系统在处理`write`系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。

# [56] 文件共享
操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件。文件系统中的软链接（Symbolic Link，又称符号链接）和硬链接（Hard Link）是两种不同的文件关联机制，其核心区别在于​**​实现原理、行为特性和适用场景​**。​
![](img/04_file_mngmnt/13%20软链接和硬链接.jpg)

| ​**​特性​**​       | ​**​硬链接​**​                                | ​**​软链接​**​                                       |
| ------------------ | --------------------------------------------- | ---------------------------------------------------- |
| ​**​本质​**​       | 同一文件的多个别名，共享同一个 inode 和数据块 | 独立文件，存储目标文件的路径字符串，拥有独立的 inode |
| ​**​创建命令​**​   | `ln source target`                            | `ln -s source target`                                |
| ​**​inode 关系​**​ | 与源文件相同（共享 inode 号）                 | 独立 inode 号                                        |
| ​**​底层存储​**​   | 仅新增目录项（不占用额外数据块）              | 占用独立数据块存储目标路径                           |

## 1.核心特性对比​​
### ​​（1）跨文件系统支持​​
- ​**​硬链接​**​：仅限同一文件系统（inode 是文件系统局部标识）
- ​**​软链接​**​：可跨文件系统、磁盘分区甚至远程路径
### ​（2）对目录的支持​​
- ​**​硬链接​**​：系统禁止用户创建目录硬链接（避免目录树循环引用）
    - 例外：文件系统内部使用（如 `.` 当前目录和 `..` 上级目录）
- ​**​软链接​**​：可自由指向目录（如 `/home/user/Desktop` 通常是软链接）

### ​（3）删除操作的影响​​
|​**​操作​**​|​**​硬链接​**​|​**​软链接​**​|
|---|---|---|
|​**​删除源文件​**​|文件数据仍可通过其他硬链接访问（inode 引用计数减1）|变为“悬空链接”（Dangling Link），访问报错|
|​**​删除链接本身​**​|仅减少引用计数，不影响数据|删除独立文件，不影响源文件|

### （​4）文件属性与行为​​
|​**​属性​**​|​**​硬链接​**​|​**​软链接​**​|
|---|---|---|
|​​文件大小​​|与源文件相同（共享数据块）|等于目标路径字符串长度（如 `target.txt` 占 10 字节）|
|​权限/时间​|与源文件完全一致（同一 inode）|自身权限为 `lrwxrwxrwx`，实际权限由目标文件决定|
|​同步性​|修改任一硬链接，所有链接同步更新|修改软链接不影响目标文件，修改目标文件同步至软链接|

## ​2.应用场景与实例​​
### ​硬链接适用场景​​
- ​**​低成本备份​**​：为重要文件创建硬链接，避免重复存储（如 `cp -l` 命令）
- ​**​共享数据​**​：多个程序共用同一库文件（如 Git 用硬链接管理对象存储）
- ​**​文件系统结构​**​：维护目录树（如 `.` 和 `..` 内置硬链接）

### ​软链接适用场景​​
- ​**​快捷方式​**​：深层目录快速访问（如 `~/Desktop` 指向实际桌面目录）
- ​**​版本管理​**​：动态切换版本（如 `/usr/bin/python` 指向 `python3.11`）
- ​**​跨文件系统引用​**​：如将 `/mnt/disk1/logs` 链接到 `/var/logs/disk1`

## ​3.技术限制与注意事项​​
1. ​**​硬链接局限性​**​
    - 无法跨文件系统，不适用于目录
    - 大量硬链接可能导致文件系统混乱（难以区分源文件）
2. ​**​软链接风险​**​
    - 路径依赖：移动或重命名目标文件会导致链接失效
    - 循环链接：`a → b` 且 `b → a` 可能导致解析崩溃（内核限制最大递归深度）
3. ​**​检测工具​**​
    - 查找硬链接：`find / -samefile file.txt` 或 `find / -inum 12345`
    - 识别软链接：`ls -l` 显示 `→` 标记；`readlink` 命令解析目标路径

💎**核心区别一句话​**​：硬链接是​**​文件的多个别名​**​（共享 inode），软链接是​**​路径的快捷方式​**​（独立 inode）。

# [57] 文件保护
## 1.文件系统保护概述
文件系统保护是保障数据安全的​**​核心防线​**​，主要通过三大机制实现：
1. ​**​口令保护​**​（Password Protection）
2. ​**​加密保护​**​（Encryption Protection）
3. ​**​访问控制​**​（Access Control）
以下从原理、实现到应用场景，系统解析三类保护机制的工作方式及其差异。

## 2.口令保护（Password Protection）
### 1.核心原理
通过​**​预置验证密钥​**​控制访问权限，是最基础的认证机制。用户需输入正确口令才能访问文件或系统资源。

### 2.保护机制实现

|​**​层级​**​|​**​实现方式​**​|​**​典型示例​**​|
|---|---|---|
|​**​系统级​**​|操作系统启动时验证口令（如BIOS密码、Windows登录密码）|`sudo`提权操作需输入密码|
|​**​文件级​**​|对特定文件/目录设置独立口令（常见于压缩软件、办公文档）|ZIP加密文件、PDF密码保护|
|​**​应用级​**​|数据库/应用程序内置口令验证（如MySQL密码、SSH密钥）|`mysqldump -p` 导出加密数据|

### 3.技术特点
- ​**​优点​**​：部署简单、用户认知度高
- ​**​局限​**​：
    - 口令易被暴力破解或钓鱼攻击
    - 不保护数据内容本身（仅控制访问入口）
    - 无法防御物理介质窃取后的数据读取

### 4.安全强化建议
```shell
# 强制使用强口令策略（Linux示例） 
sudo vim /etc/pam.d/common-password 
# 添加：password requisite pam_pwquality.so minlen=12 difok=3 ucredit=-1 lcredit=-1 dcredit=-1`
```

## 3.加密保护（Encryption Protection）
### 1.核心原理
通过​**​密码学算法​**​将明文数据转为密文，只有持有密钥者能还原原始内容。

### 2.保护机制实现
|​**​加密类型​**​|​**​技术原理​**​|​**​应用场景​**​|
|---|---|---|
|​**​全盘加密​**​|整个存储设备加密（如BitLocker、LUKS）|笔记本电脑防丢失|
|密钥机制：|AES-256对称加密||
|​**​文件级加密​**​|单个文件/目录加密（如GPG、EFS）|敏感文档保护|
|密钥机制：|非对称加密（公钥加密，私钥解密）||
|​**​端到端加密​**​|数据传输中持续加密（如TLS/SSL）|网络文件传输（SFTP/HTTPS）|

### 3.技术特点
- ​**​核心优势​**​：
    - 即使数据被窃取也无法解读（物理攻击无效）
    - 支持细粒度访问控制（不同密钥访问不同文件）
- ​**​挑战​**​：
    - 密钥丢失=数据永久丢失（需备份策略）
    - 加密/解密消耗计算资源（影响I/O性能）

### 4.Linux加密实战（LUKS示例）
```shell
# 创建加密卷 
sudo cryptsetup luksFormat /dev/sdb1 

# 映射解密设备 
sudo cryptsetup open /dev/sdb1 my_encrypted_vol 

# 格式化并挂载 
sudo mkfs.ext4 /dev/mapper/my_encrypted_vol 
sudo mount /dev/mapper/my_encrypted_vol /mnt/secure
```

## 4.访问控制（Access Control）
### 1.核心原理
通过​**​权限元数据​**​精确控制:"谁能在什么条件下执行何种操作"。
### 2.保护机制实现
#### (1) 自主访问控制（DAC）
- ​**​工作机制​**​：资源所有者自主分配权限
- ​**​权限模型​**​：
    - ​**​Linux/UNIX​**​：`rwx` 权限位（用户/组/其他）
    - ​**Windows**​​： ACL访问控制列表（用户/组/权限条目）

```shell
-rwxr-x--- 1 user group 4096 Jan 1 10:00 secret.txt 
# 解释：用户可读写执行，组用户可读执行，其他无权限
```        

#### (2) 强制访问控制（MAC）
- ​**​工作机制​**​：系统级策略强制管理权限（无视用户设置）
- ​**​实现模型​**​：
    - ​**​SELinux​**​（Linux）：基于安全上下文标签
    - ​**​AppArmor​**​（Linux）：基于路径的访问规则
    - ​**​Windows Integrity机制​**​：进程/对象分级保护
#### (3) 基于角色的访问控制（RBAC）
- ​**​工作机制​**​：权限绑定角色而非用户
- ​**​典型场景​**​：
    - 企业文件系统：角色如`admin`、`developer`、`auditor`
    - 云存储服务：AWS IAM 角色策略

### 3.技术特点
|​**​控制类型​**​|​**​灵活性​**​|​**​安全性​**​|​**​管理成本​**​|
|---|---|---|---|
|DAC|★★★★☆|★★☆☆☆|低|
|MAC|★★☆☆☆|★★★★★|高|
|RBAC|★★★☆☆|★★★★☆|中|

## 5.三类保护机制对比与协同

|​**​维度​**​|口令保护|加密保护|访问控制|
|---|---|---|---|
|​**​保护对象​**​|访问入口|数据内容本身|操作权限|
|​**​破解难度​**​|低（依赖口令强度）|极高（需密钥）|中（依赖配置）|
|​**​防御场景​**​|非法登录|物理窃取/嗅探|越权操作|
|​**​最佳实践组合​**​|多因子认证+强口令|AES-256全盘加密|SELinux+RBAC|

### 协同应用案例：企业敏感文档保护
1. ​**​口令保护​**​：强制AD域账户+动态令牌双因素认证
2. ​**​加密保护​**​：BitLocker加密硬盘+EFS文件级加密
3. ​**​访问控制​**​：
    - DAC：设置`财务组`可读写
    - MAC：SELinux阻止非授权进程访问
    - RBAC：审计员角色仅限读取

# [59] 文件系统的层次结构
操作系统的文件系统的层次结构分为：用户接口、文件目录系统、存取控制模块、逻辑文件系统、物理文件系统、设备管理模块。

![](img/04_file_mngmnt/14%20文件系统层次架构.jpg)

Linux 系统，就是以虚拟文件系统（VFS），作为linux内核和具体I/O设备之间的封装的一层共通访问接口，通过这层接口，linux内核可以以同一的方式访问各种I/O设备。

![](img/04_file_mngmnt/15%20VFS架构.jpg)