#操作系统 
# [25] 生产者-消费者问题
## 问题描述
系统中有一组生产者进程和一组消费者进程（可能是多个），生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）生产者、消费者共享一个初始为空、大小为`n`的缓冲区。

![](img/02_process_mngmnt/53%20生产者-消费者模式.jpg)

★要求：
- 只有**缓冲区没满**时，生产者**才能把产品放入缓冲区**，否则必须等待。
- 只有**缓冲区不空**时，消费者**才能从中取出产品**，否则必须等待。
- 缓冲区是临界资源，各进程必须互斥地访问。

## 问题分析
PV操作题目分析步骤：
1. 关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。
2. 整理思路。根据各进程的操作流程确定P、V操作的大致顺序。
3. 设置信号量。并根据题目条件确定信号量初值。（**互斥信号量初值一般为**1，**同步信号量的初始值**要看对应资源的初始值是多少）

在这样的环境下，设置信号量如下：
```c
semaphore mutex = 1;   // 互斥信号量，实现对缓冲区的互斥访问

semaphore empty = n;   // 同步信号量，表示空闲缓冲区的数量 
semaphore full = 0;    // 同步信号量，表示产品的数量，也即非空缓冲区的数量
```

## 代码实现
信号量同步机制：
```c
// 占有信号量资源 --- wait
P(semaphore s) {
	while(s == 0);  // 忙等
	s--;
}

// 释放信号量资源 --- signal
V(semaphore s) {
	s++;
}
```

生产者：
```c
// 生产者
producer ()
{ 
	while(true) { 
		produce();  // 生产一个产品; 
		
		P(empty);   // 占有一个空闲缓冲区资源
		
		P(mutex);   // 加锁
		buffer_in_put();  // 把产品放入缓冲区; 
		V(mutex);   // 解锁
		
		V(full);    // 释放非缓冲区资源（非缓冲区-1）
	} 
}
```
消费者：
```c
consumer ()
{ 
	while(true) { 
		P(full);    // 占据一个非缓冲区资源（非缓冲区+1）
		
		P(mutex);   // 加锁
		buffer_out_put();  //从缓冲区取出一个产品; 
		V(mutex);   // 解锁
		
		V(empty);   // 释放一个缓冲区资源
		consume();  // 使用产品; 
	}
}
```

站在空间的角度，空间被占用和不被占用是两种对立的状态，一个缓冲区，空闲资源和非空闲资源也是描述这个缓冲区两个对立的属性，虽然两者相关联，但是，对于生产者而言，每生产一个，就是实际上在占有一个空闲空间，释放一个非空空间（有点难理解，释放非空空间就是满空间资源数被归还+1），对于消费者恰恰相反。无法理解非空空间，不妨站在阴阳黑白的角度，思考下空间的对立的实体。实体（embody）和空间（space）相互对立，每个空间的资源减少对应实体资源的增加，而生产者非缓冲区资源的释放，就意味着实体（embody）资源的释放。

![](img/02_process_mngmnt/54%20生产者-消费者模式解释.jpg)
生产者消费者问题是一个**互斥、同步**的综合问题。 对于初学者来说最难的是发现题目中隐含的**两对同步关系**。 有时候是消费者需要等待生产者生产（空缓冲区无法消费），有时候是生产者要等待消费者消费（满缓冲区无法生产），因此，这是不是一个简单的前后依赖关系，而是两个不同的“一前一后问题”，因此也需要设置两个同步信号量。

## 顺序问题
是否可以改变同一个进程的P、V操作顺序，例如将：
```c
P(empty);   // 占有一个空闲缓冲区资源
```
和
```c
P(mutex);   // 加锁
```
对调，变成：
```c
// 生产者
producer ()
{ 
	while(true) { 
		produce();  // 生产一个产品; 

		P(mutex);   // 先加锁                    ----- P1
		P(empty);   // 再占有一个空闲缓冲区资源    ----- P2
		buffer_in_put();  // 把产品放入缓冲区; 
		V(mutex);   // 解锁
		
		V(full);    // 释放非缓冲区资源（非缓冲区-1）
	} 
}

// 消费者
consumer ()
{ 
	while(true) { 
	    P(mutex);   // 加锁                            ----- P3
		P(full);    // 占据一个非缓冲区资源（非缓冲区+1） ----- P4

		buffer_out_put();  //从缓冲区取出一个产品; 
		V(mutex);   // 解锁
		
		V(empty);   // 释放一个缓冲区资源
		consume();  // 使用产品; 
	}
}

```
是否会有其他问题？   

若此时缓冲区内已经放满产品，则 `empty = 0，full = n`。  
- 生产者进程执行 P1，使mutex变为0，
- 再执行 P2，由于已**没有空闲缓冲区，因此生产者被阻塞**。 
- 由于生产者阻塞，循环结束，因此切换回消费者进程。消费者进程执行P3，
- 由于mutex为0，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞。 
- 这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”。 
- 同样的，若缓冲区中没有产品，即full=0，empty=n。
- 按P3、P4、P1的顺序执行就会发生死锁。   
因此，**实现互斥的P操作一定要在实现同步的P操作之后**。但是，V操作不会导致进程阻塞，因此两个V操作顺序可以交换。

# [26] 多生产者-多消费者问题
## 问题场景
桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。 用`P - V`操作实现上述过程。

![](img/02_process_mngmnt/55%20多生产者多消费者.jpg)
- 互斥关系：（mutex = 1）对缓冲区（盘子）的访问要互斥地进行
- 同步关系：（一前一后）： 
	1. **父亲将苹果放入盘子后，女儿才能取苹果** 
	2. **母亲将橘子放入盘子后，儿子才能取橘子** 
	3. **只有盘子为空时，父亲或母亲才能放入水果**

![](img/02_process_mngmnt/56%20PV-多生产多消费.jpg)

## 程序实现
“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果。
```c
semaphore mutex = 1;   // 实现互斥访问盘子（缓冲区） 
semaphore apple = 0;   // 盘子中有几个苹果 
semaphore orange = 0;  // 盘子中有几个橘子 
semaphore plate = 1;   // 盘子中还可以放多少个水果
```

```c
dad() { 
	while(1) { 
		准备一个苹果;
		P(plate);       // 占有盘子资源
		
		P(mutex);
		把苹果放入盘子;
		V(mutex);
		
		V(apple);      // 释放苹果资源，苹果资源 +1
	} 
}
```

```c
mom() { 
	while(1) {
		准备一个橘子;
		P(plate);     // 占有盘子资源
		
		P(mutex);
		把橘子放入盘子;
		V(mutex);
		
		V(orange);   // 释放橙子资源，橙子资源 +1
	} 
}
```

```c
daughter() { 
	while(1) { 
		P(apple);    // 占有苹果资源（消费）
		
		P(mutex);
		从盘中取出苹果;
		V(mutex);
		
		V(plate);    // 释放盘子资源
		吃掉苹果;
	} 
}
```

```c
son() {
	while(1){
		P(orange);   // 占有橙子资源（消费）

		P(mutex);
		从盘中取出橘子;
		V(mutex);

		V(plate);    // 释放盘子资源
		吃掉橘子;
	}
}
```

## 不适用mutex互斥信号量
如果刚开始是父亲进程先上处理机运行，则： 
父亲 P(plate)，可以访问盘子 → 母亲 P(plate)，阻塞等待盘子 → 父亲放入苹果 V(apple)，女儿进程被唤醒，其他进程即使运行也都会阻塞，暂时不可能访问临界资源（盘子）→ 女儿 P(apple)，访问盘子，V(plate)，等待盘子的母亲进程被唤醒 → 母亲进程访问盘子（其他进程暂时都无法进入临界区）→ 

父亲 P(plate)，可以访问盘子à母亲 P(plate)，可以访问盘子à父亲在往盘子里放苹果，同时母亲也可以往盘子里 放橘子。于是就出现了两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。 因此，如果缓冲区大小大于1，就必须专门设置一个互斥信号量 mutex 来保证互斥访问缓冲区。


# [27] 吸烟者问题
吸烟者问题（Cigarette smokers problem），假设一个系统有三个**抽烟者进程**和一个**供应者进程**。
每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。**供应者进程无限地提供三种材料**，供应者**每次将两种材料放桌子上**，拥有剩下**那种材料的抽烟者卷一根烟并抽掉它**，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）。

![](img/02_process_mngmnt/57%20吸烟者问题.jpg)


本质上这题也属于“生产者-消费者”问题，更详细的说应该是“**可生产多种产品的单生产者-多消费者**”。
1. 关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。 
2. 整理思路。根据各进程的操作流程确定P、V操作的大致顺序 
3. 设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）。    

桌子可以抽象为容 量为1的缓冲区，要互斥访问。

# [27] 读者写者问题
有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：
1. 允许多个读者可以同时对文件执行读操作；
2. 只允许一个写者 往文件中写信息；
3. 任一写者在完成写操作之前不允许其他读者或写者工作；
4. 写者执行写操作前，应让已有的读者和写者全部退出。

- **关系分析**。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。 
- **整理思路**。根据各进程的操作流程确定P、V操作的大致顺序 
- **设置信号量**。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为1， 同步信号量的初始值要看对应资源的初始值是多少）。

思考：若两个读进程并发执行，则 count=0 时两个进程也许都能满足 if 条件，都会执行 P(rw)，从而使第二个读进程阻塞的情况。 如何解决：出现上述问题的原因在于对 count 变量的检查和赋值无法一气呵成，因 此可以设置另一个互斥信号量来保证各读进 程对count 的访问是互斥的。

# [28] 哲学家进餐问题
一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学 家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。

# [29] 管程
信号量机制存在的问题：编写程序困难、易出错。
