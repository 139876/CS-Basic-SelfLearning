#操作系统 
# [44] 基本分段存储管理
与“分页”最大的区别就是——离散分配时所分配的地址空间的基本单位不同。
## 分段（Memory segmentation）
- 进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址。
- 内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。  

由于是按逻辑功能模块划分，用户编程更方便，程序的可读性更高。

![](img/03_memory_mngmnt/38%20分段.jpg)
分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成。
- 段号（segment number）的位数决定了每个进程最多可以分几个段；
- 段内（offset）地址位数决定了每个段的最大长度是多少。

程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中 找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”（segment table），即图中的黑框部分。   
段表中的每个段对应一个段表项，其中记录了该段在内存中的**起始位置**（base，又称 “基址”）和**段的长度**（limit）。虽然内存中的每个段的大小不同，但是各个段表项的长度是相同的（很容易理解，记录这些段信息的每一行的长度是相同的）。

![](img/03_memory_mngmnt/39%20处理机视角的分段寻址.jpg)

【例子】   
某系统按字节寻址，采用分段存储管理，逻辑地址结构为段号（segment number） 16位, 段内地址（offset） 16位，因此用16位，即可表示最大段长（max limit）。物理内存大小为4GB（可用32位表示整个物理内存地址空间）。因此，可以让每个段表项占 16（offset）+32（base）= 48位，即6B（48bit）。由于段表项长度相同，因此段号可以是隐含的，不占存储空间（数组根据地址求序号）。若段表存放的起始地址为 `M`，则 K号段对应的段表项存放的地址为 `M + K*6`。

## 地址变换
计算机中存储进程的分段信息，位于分段寄存器（segment registers）中。

![](img/03_memory_mngmnt/40%20段寄存器.jpg)
如何根据段寄存器中的信息，获取真实物理地址。按照以下步骤。
1. 根据逻辑地址得到段号（segment No.）、段内地址（Offset）。
2. 判断段号是否越界，越界，则中断；
3. 查询段表（segment table），找到对应的段表项。
4. 检查段内地址是否超过段长（limit）， 越界，则中断；
5. 根据偏移，计算得到物理地址。

![](img/03_memory_mngmnt/41%20分段地址变换.jpg)
## 分段与分页
|            | 段                                                                                       | 页                                                                         |
| ---------- | ---------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| 存储层次   | 段是信息的逻辑单位。 一个段通常包含着一组属于一个逻辑模块的信息。                        | 页是信息的物理单位。                                                       |
| 目的       | 分段的主要目的是更好地满足用户需求。                                                     | 分页的主要目的是为了实现离散分配，提高内存利用率。                         |
| 使用者可见 | 分段对用户是可见的，用户编程时需要显式地给出段名。                                       | 分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。             |
| 大小       | 段的长度却不固定，决定于用户编写的程序。                                                 | 页的大小固定且由系统决定。                                                 |
| 维度       | 分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。 | 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。 |

![](img/03_memory_mngmnt/42%20分段分页区别.jpg)

需要单独提出来的是，分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的。
 

# [45] 段页式管理方式
## 两种管理方式的优缺点
|          | 优点                                                     | 缺点                                                                         |
| -------- | -------------------------------------------------------- | ---------------------------------------------------------------------------- |
| 分页管理 | 内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片 | 不方便按照逻辑模块实现信息的共享和保护                                       |
| 分段管理 | 很方便按照逻辑模块实现信息的共享和保护                   | 如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片 |

分段管理中产生的外部碎片也 可以用“紧凑”（Compress，压缩）技术来解决，只是需要付出较大的时间代价。

## 段页式（Segmentation with Paging，Segmented Paging）
段页式综合两种方式。将进程按逻辑模块分段（segment），再将各段分页（paging，如每个页面4KB），再将内存空间分为大小相同的内存块（page frame，页框/页帧/物理块），进程前将各页面分别装入各内存块中。

![](img/03_memory_mngmnt/43%20段页式.jpg)
段页式系统的逻辑地址结构由段号、页号、页内地址（页内偏移量）组成。如上图。
- 段号（Segment No.）的位数决定了每个进程最多可以分几个段 
- 页号（Page No.）位数决定了每个段最大有多少页 
- 页内偏移量（Page Offset）决定了页面大小、内存块大小是多少。

“分段”对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此**段页式管理的地址结构是二维的**。
段页式存储，囊括了**段表和页表**。

![](img/03_memory_mngmnt/44%20段页式段表和页表.jpg)

- 每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。每个段表项长度相等，段号是隐含的。 
- 每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。

## 地址变换
![](img/03_memory_mngmnt/44%20段页式三次访存.jpg)
段页式存储地址转换需要经历**三次访存**：
1. 根据逻辑地址得到段号、页号、页内偏移量；
2. 判断段号是否越界；
3. 查询段表，找到对应的段表项；
4. 检查页号是否越界；
5. 根据页表存放块号、页号查询页表，找到对应页表项；
6. 根据内存块号、页内偏移量得到最终的物理地址；
7. 访问目标内存单元。

# [46] 虚拟内存的基本概念

# [47] 请求分页管理方式

# [48] 页面置换算法

# [49] 页面分配策略、抖动、工作集