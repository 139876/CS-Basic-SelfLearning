#操作系统 
# [18] FCFS、SJF、HRRN调度算法
## ★ 调度算法的关注重点
1. 算法思想
2. 算法规则
3. 这种调度算法是用于作业调度还是进程调度？
4. 算法属于抢占式？非抢占式？
5. 算法的优点和缺点
6. 是否会导致饥饿（某进程/作业长期得不到服务）？

## 1. FCFS 先来先服务算法（First Come First Serve）
1. **算法思想**
主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）。
2. **算法规则**
按照作业/进程到达的先后顺序进行服务。
3. **用于作业/进程调度**
用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。
4. **是否可抢占**？
**非抢占式**的算法。
以如下的例子，四个进程按照顺序进入处理机计算，其周转时间、带权周转时间和等待时间如图。

![](img/02_process_mngmnt/34%20FCFS%20先来先服务算法.jpg)

注意：本例中的进程都是纯计算型的进程，一个进程到达后要么在等待，要么在运行。如果是又有计算、又有I/O操作的进程，其**等待时间**就是**周转时间 — 运行时间 —I/O操作的时间**

5. **优缺点**
优点：公平、算法实现简单
缺点：排在长作业（进程）后面的短作业需要等待很长时间，**带权周转时间很大**，对短作业来说用户体验不好。即FCFS算法对**长作业有利**，对**短作业不利**。
6. **是否会导致饥饿** ？
不会。

## 2. SJF/ SPF 短作业/短进程优先（Shortest Job/Process First）
1. **算法思想**
追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间。
2. **算法规则**
最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）
3. **用于作业/进程调度**
可用于作业调度，也可用于进程调度。
用于作业调度，称为“短作业优先（`SJF`，`Shortest Job First`）算法”
用于进程调度，称为“短进程优先（`SPF`，`Shortest Process First`）算法”
4. **是否可抢占**？
`SJF`和`SPF`均为非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法（`SRTN`, `Shortest Remaining Time Next`）
5. **优缺点**
- 优点：“最短的”平均等待时间、平均周转时间。
- 缺点：不公平。对短作业有利，对长作业不利。作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。
6. **是否会导致饥饿** ？
可能产生饥饿现象。另外，如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“**饥饿**”现象。如果一直得不到服务，则称为“**饿死**”。

以如下的例子，四个进程按照顺序进入处理机计算，使用非抢占式的短进程优先调度算法（`SPF`，`Shortest Process First`），其周转时间、带权周转时间和等待时间如图。

![](img/02_process_mngmnt/35%20短进程优先算法.jpg)

对比FCFS算法的结果，显然SPF算法的平均等待/周转/带权周转时间都要更低。

**最短剩余时间优先算法**：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个**进程完成时**也需要**调度**。

![](img/02_process_mngmnt/36%20最短剩余时间优先.jpg)

对比**非抢占式**的短作业优先算法，显然**抢占式**的这几个指标又要更低。
虽然严格来说，`SJF`的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 `FCFS`），
`SJF`依然可以获得较少的平均等待时间、平均周转时间。

## 3. HRRN 高响应比优先（Highest Response Ratio Next）

1. **算法思想**
要综合考虑作业/进程的等待时间和要求服务的时间。
2. **算法规则**
在每次调度时先计算各个作业/进程的**响应比**，选择响应比最高的作业/进程为其服务。
$$响应比 = \frac{等待时间+要求服务时间}{要求服务时间}$$

3. **用于作业/进程调度**
可用于作业调度，也可用于进程调度。

![](img/02_process_mngmnt/37%20高响应比优先.jpg)

4. **是否可抢占**？
非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比。
5. **优缺点**
- 综合考虑了等待时间和运行时间（要求服务时间）
- 等待时间相同时，要求服务时间短的优先（SJF 的优点）
- 要求服务时间相同时，等待时间长的优先（FCFS 的优点）
- 对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题。
6. **是否会导致饥饿** ？
不会。

## 总结

| 算法    | 是否可抢占 | 优点 | 缺点 | 是否考虑等待时间和运行时间 | 是否会导致饥饿 |
| ------- | ---------- | ---- | ---- | -------------------------- | -------------- |
| FCFS    | 非抢占式   | 公平；实现简单  |对短作业不利 | 等待时间√ 运行时间×      |   **不会**             |
| SJF/SPF |默认为非抢占式，也有抢占式版本（SRTN算法）|“最短的”平均等待/周转时间| 对长作业不利，难以做到真正的短作业优先| 等待时间× 运行时间√  |**会** |
| HRRN   | 非抢占式   |上述两种算法的权衡折中，综合考虑的等待时间和运行时间  ||等待时间√ 运行时间√ |**不会**|

以上这三种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。
因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。

# [19] 调度算法：时间片轮转、优先级、多级反馈队列
## 1. 时间片轮转（RR, Round-Robin）
1. **算法思想**
公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。
2. **算法规则**
按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。
3. **用于作业/进程调度**
用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）。
4. **是否可抢占**？
抢占式的算法。
若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此**时间片轮转调度**算法属于抢占式的算法。由**时钟装置发出时钟中断**来通知CPU时间片已到。
5. **优缺点**
- 优点：公平；响应快，适用于分时操作系统；
- 缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。
6. **是否会导致饥饿** ？
不会。

![](img/02_process_mngmnt/38%20时间片轮转算法.jpg)
![](img/02_process_mngmnt/39%20时间片轮转算法.jpg)
![](img/02_process_mngmnt/40%20时间片轮转算法.jpg)

如上图，如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法**退化为先来先服务**调度算法，并且会增大进程响应时间。因此时间片不能太大。

切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。
比如：系统中有10个进程在并发执行，如果时间片为1秒，则一个进程被响应可能需要等9秒…也就是说，如果用户在自己进程的时间片外通过键盘发出调试命令，可能需要等待9秒才能被系统响应。
因此，一般而言，**设计时间片时要让切换进程的开销占比不要超过1%**。

## 2. 优先级调度算法（Priority Scheduling）
1. **算法思想**
随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据**任务的紧急程度**来决定处理顺序。
2. **算法规则**
每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。
3. **用于作业/进程调度**
既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的**I/O调度**中。
4. **是否可抢占**？
抢占式、非抢占式都有。
区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。
## ★ 补充
就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置。
根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。
- 静态优先级：创建进程时确定，之后一直不变。
- 动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。

![](img/02_process_mngmnt/41%20优先级调度算法.jpg)
![](img/02_process_mngmnt/43%20优先级调度算法.jpg)

- **优先级设定**：
1. 系统进程优先级 高于 用户进程
2. 前台进程优先级 高于 后台进程
3. 操作系统更偏好 **I/O型进程**（或称 I/O繁忙型进程）
    注：与I/O型进程相对的是**计算型进程**（或称 CPU繁忙型进程）
I/O设备和CPU可以并行工作。
如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升。

- **采用的是动态优先级，什么时候应该调整**？
可以从追求公平、提升资源利用率等角度考虑：
1. 如果某进程在**就绪队列中等待了很长时间**，则可以适当提升其优先级。
2. 如果某进程占用处理机**运行了很长时间**，则可适当降低其优先级。
3. 如果**发现一个进程频繁地进行I/O操作**，则可适当提升其优先级。

5. **优缺点**
- 优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。
- 缺点：若源源不断地有高优先级进程到来，则可能导致饥饿
6. **是否会导致饥饿** ？
会。

## 3. 多级反馈队列调度算法
1. **算法思想**
对其他调度算法的**折中权衡**。
2. **算法规则**
    1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
    2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾。
    3. 只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片
3. **用于作业/进程调度**
用于进程调度。
4. **是否可抢占**？
**抢占式**的算法。在 k 级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。

![](img/02_process_mngmnt/44%20多级反馈队列算法.jpg)

5. **优缺点**
    - 对各类型进程**相对公平**（FCFS的优点）；
    - 每个新到达的进程都可以**很快就得到响应**（RR的优点）；
    - 短进程只用**较少的时间**就可完成（SPF的优点）；
    - 不必实现**估计进程的运行时间**（避免用户作假）；
    - 可**灵活地调整**对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）
6. **是否会导致饥饿** ？
会。
## 调度算法总结

| 算法         | 思想   | 是否可抢占                       | 优点                       | 缺点                               | 是否会饥饿 | 补充                                                        |
| ------------ | ------ | -------------------------------- | -------------------------- | ---------------------------------- | ---------- | ----------------------------------------------------------- |
| 时间片轮转   |        | 抢占式                           | 公平，适用于分时系统       | 频繁切换有开销，不区分优先级       | 不会       | 时间片太大或太小有重要影响？                                |
| 优先级调度   |        | **有抢占式的，也有非抢占式的**。 | 区分优先级，适用于实时系统 | 可能导致饥饿                       | 会         | 动态/静态优先级。各类型进程如何设置优先级？如何调整优先级？ |
| 多级反馈队列 | 较复杂 | 抢占式                           | 平衡优秀                   | 一般不说它有缺点，不过可能导致饥饿 | 会         |                                                             |

比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的**交互式操作系统**（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。
而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统（比如UNIX使用的就是多级反馈队列调度算法）。


