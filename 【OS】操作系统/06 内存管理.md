#操作系统 
## [35]  内存的基础知识
内存可存放数据。程序执行前需要先放到内存中才能被CPU处理，内存缓和了CPU与硬盘之间的速度矛盾。

在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？
方法：给内存的存储单元编地址。内存地址从0开始，每个地址对应一个存储单元。

内存中也有一个一个的“小房间”，每个小房间就是一个“**存储单元**”。
如果计算机“**按字节编址**”，则每个存储单元大小为 1字节，即 1B，即 8个二进制位。
如果字长为16位的计算机“**按字编址**”，则每个存储单元大小为 **1个字**；每个字的大小为 16 个二进制位。

我们写的代码要翻译成**CPU能识别的指令**。这些指令会告诉CPU应该去**内存的哪个地址读/写数据**，
这个数据应该做什么样的处理。在这个例子中，我们默认让这个进程的相关内容从地址`#0`开始连续存
放，指令中的地址参数直接给出了变量 x 的实际存放地址（物理地址）。

思考：如果这个进程不是从地址#0 开始存放的，会影响指令的正常执行吗？

指令的工作原理
程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址），即：相对于进程的起始地址而言的地址。
C语言程序经过编译、链接处理后，生成装入模块，即可执行文件：int x = 10;x = x+1;

装入的三种方式

- **绝对装入**：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。
Eg：如果知道装入模块要从地址为 100 的地方开始存放…
绝对装入只适用于**单道程序环境**。
程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。

- **动态重定位**：
又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。
装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。

- **动态重定位**：又称动态运行时装入。
编译、链接后的装入模块的地址都是从0开始的。
装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。
因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。

采用动态重定位时允许程序在内存中发生移动。
且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的
地址空间。


**从写程序到程序运行**
- 编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言）
- 链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块
- 装入（装载）：由装入程序将装入模块装入内存运行


**链接的三种方式**
1. 静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。
2. 装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式。
3. 运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。

## [36]  内存管理的概念
操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？

1. 操作系统负责**内存空间的分配与回收**。
2. 操作系统需要提供某种技术从逻辑上对内存空间进行扩充。
3. 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。
4. 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。

>为了使编程更方便，程序员写程序时应该只需要关注**指令、数据**的逻辑地址。
>而逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。

**内存保护**
内存保护可采取两种方法：
方法一：在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。

方法二：采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。

## [37]  覆盖与交换

早期的计算机内存很小，比如 IBM 推出的第一台PC机最大只支持 1MB 大小的内存。因此经常会出现内存大小不够的情况。
后来人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题。

覆盖技术的思想：将程序分为多个段（多个模块）。
常用的段常驻内存，不常用的段在需要时调入内存。内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束），不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。

必须由程序员声明覆盖结构，操作系统完成自动覆盖。
缺点：对用户不透明，增加了用户编程负担。
覆盖技术只用于早期的操作系统中，现在已成为历史。

交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）
中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。

交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）。
暂时换出外存等待的进程状态为挂起状态（挂起态，suspend），挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。

交换技术
交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中
某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）。

1. 应该在外存（磁盘）的什么位置保存被换出的进程？
2. 什么时候应该交换？
3. 应该换出哪些进程？

1. 具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式（学过文件管理章节
后即可理解）。总之，对换区的I/O速度比文件区的更快。
2. 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在
发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；
如果缺页率明显下降，就可以暂停换出。
3. 可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调
入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…
（注意：PCB 会常驻内存，不会被换出外存）

## [38]  连续分配管理方式
### 单一连续分配

在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。
内存中只能有一道用户程序，用户程序独占整个用户区空间。
优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的 PC 操作系统 MS-DOS）。
缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。


分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”。
20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。

分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合（比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序）
分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）。

### 固定分区分配
操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。

当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。

优点：实现简单，无外部碎片。
缺点：a. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；b. 会产生内部碎片，内存利用率低。
### 动态分区分配
动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，
根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数
目是可变的。（eg：假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56 MB…）

1. 系统要用什么样的数据结构记录内存的使用情况？
2. 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息。
空闲分区表：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息。
空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息。

当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？
应该用最大的分区进行分配？还是用最小的分区进行分配？又或是用地址最低的部分进行分配？
把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。


动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，
根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数
目是可变的。
动态分区分配没有内部碎片，但是有外部碎片。
内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。
外部碎片，是指内存中的某些空闲分区由于太小而难以利用。

如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑（拼凑，Compaction）技术来解决外部碎片。

## [39]  动态分区分配算法

## [40]  基本分页存储管理的概念

## [41]  基本地址变换机构

## [42]  具有快表的地址变换机构

## [43]  两级页表

## [44]  基本分段存储管理

## [45]  段页式管理方式

## [46]  虚拟内存的基本概念

## [47]  请求分页管理方式

## [48]  页面置换算法

## [49]  页面分配策略、抖动、工作集
